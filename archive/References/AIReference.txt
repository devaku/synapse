AI Reference Page:
    so how to use this... copy and paste convo basically that includes the prompt,
    answer from AI and whatnot. You could do:
        AI: Claude V.### / ChatGPT 5/4 / QodoGen / That Shark one and its version
        Prompt: asdadadadasdasdadasda
        Answer: asdadasdasdadadadadad

*** For created a json file for testing
        User: give me like‚Ä¶ idk‚Ä¶ 999 more objects for ‚Äúdata‚Äù if possible, keep
        it too like 10 different users and simple descriptions, dont change the
        columns Assistant: I generated 999 more log entries with the same
        structure (10 different users and simple descriptions) and saved them in
        a new file: logs_table_testing_extended.json Would you like me to also
        give you a quick preview sample (e.g., first 5 and last 5 rows) so you
        can see how the data looks before you use it? User: export chat
        Assistant: Do you want me to export this entire chat conversation
        (everything we‚Äôve discussed so far), or just the part related to your
        logs_table_testing.json work?
        I can generate it for you in formats like TXT, DOCX, PDF. Which format
        do you prefer? User: txt

*** For updating test json
        User: add userid, a createdat time or replace timestamp with createdat, add isdeleted boolean of true or false

        Assistant: I‚Äôve updated your JSON:
        - Replaced `timestamp` with `createdAt`
        - Added a new `userID` field (sequentially assigned)
        - Added a new `isDeleted` field (defaulted to `false`)

        You can download the updated file here:
        üìÇ logs_table_testing_extended_updated.json

        Would you like me to randomize `userID` values (so the same user always has the same ID), instead of just assigning sequential numbers?

        User: give me chat in txt

        Assistant: Here‚Äôs the chat saved as a text file:
        üìÇ chat_export.txt

        User: also give me a more complex userid... and timezone with createdat... then export chat as well to txt

        Assistant: I‚Äôve updated your JSON again:
        - `userID` is now a more complex hashed ID (based on username, 12 hex chars)
        - `createdAt` now includes timezone (stored in ISO 8601 UTC format)
        - `isDeleted` is still `false` by default

        You can download the updated JSON here:
        üìÇ logs_table_testing_extended_complex.json

***Access table json for testing:
  Chat export

  --- User ---
  const columns = [
    {
      name: 'ID',
      selector: (row: any) => row.id,
      sortable: true,
    },
    {
      name: 'Repository Name',
      selector: (row: any) => row.repo_name,
      sortable: true,
    },
    {
      name: 'Requesting User',
      selector: (row: any) => row.requesting_user,
      sortable: true,
    },
    {
      name: 'Access Requested',
      selector: (row: any) => row.access_requested,
      sortable: true,
    },
  ]; make me a json with like 20 objects for these columns

  --- Assistant ---
  Here‚Äôs a JSON with 20 objects that match your `columns` definition (`id`, `repo_name`, `requesting_user`, `access_requested`):

  [
    {
      "id": 1,
      "repo_name": "frontend-ui",
      "requesting_user": "alice",
      "access_requested": "read"
    },
    {
      "id": 2,
      "repo_name": "backend-api",
      "requesting_user": "bob",
      "access_requested": "write"
    },
    {
      "id": 3,
      "repo_name": "data-pipeline",
      "requesting_user": "charlie",
      "access_requested": "admin"
    },
    {
      "id": 4,
      "repo_name": "infra-config",
      "requesting_user": "diana",
      "access_requested": "read"
    },
    {
      "id": 5,
      "repo_name": "mobile-app",
      "requesting_user": "edward",
      "access_requested": "write"
    },
    {
      "id": 6,
      "repo_name": "design-assets",
      "requesting_user": "frank",
      "access_requested": "read"
    },
    {
      "id": 7,
      "repo_name": "analytics-service",
      "requesting_user": "grace",
      "access_requested": "admin"
    },
    {
      "id": 8,
      "repo_name": "ci-cd-scripts",
      "requesting_user": "henry",
      "access_requested": "write"
    },
    {
      "id": 9,
      "repo_name": "docs",
      "requesting_user": "irene",
      "access_requested": "read"
    },
    {
      "id": 10,
      "repo_name": "ml-models",
      "requesting_user": "jack",
      "access_requested": "admin"
    },
    {
      "id": 11,
      "repo_name": "security-tools",
      "requesting_user": "karen",
      "access_requested": "read"
    },
    {
      "id": 12,
      "repo_name": "chat-service",
      "requesting_user": "leo",
      "access_requested": "write"
    },
    {
      "id": 13,
      "repo_name": "game-engine",
      "requesting_user": "maria",
      "access_requested": "admin"
    },
    {
      "id": 14,
      "repo_name": "support-bot",
      "requesting_user": "nick",
      "access_requested": "read"
    },
    {
      "id": 15,
      "repo_name": "billing-system",
      "requesting_user": "olivia",
      "access_requested": "write"
    },
    {
      "id": 16,
      "repo_name": "marketing-site",
      "requesting_user": "peter",
      "access_requested": "read"
    },
    {
      "id": 17,
      "repo_name": "search-service",
      "requesting_user": "quinn",
      "access_requested": "admin"
    },
    {
      "id": 18,
      "repo_name": "file-storage",
      "requesting_user": "rachel",
      "access_requested": "read"
    },
    {
      "id": 19,
      "repo_name": "notifications",
      "requesting_user": "sam",
      "access_requested": "write"
    },
    {
      "id": 20,
      "repo_name": "dev-tools",
      "requesting_user": "tina",
      "access_requested": "admin"
    }
  ]

  --- User ---
  extort chat to txt

***For access testing data
  # Chat Conversation Export

  ## User Message 1:
  [Image of database schema showing columns: id, priority, name, description, image, startDate, completeDate, createdAt, isDeleted, createdByUserId with their respective data types]

  imagine this is a json for a coding company, make actual task names and give them description between 100 and 200 words if possible and create for me a json of 20 object with this screenshot in mind, keep it to 5 different userid for createdbyuserid and priorities are either PENDING, OVERDUE, DELIVERED

  ## Claude Response 1:
  I'll create a JSON array of 20 task objects for a coding company based on your database schema. Here's a realistic dataset with actual development tasks:

  [Created JSON artifact with 20 coding tasks - initially with long descriptions]

  ## User Message 2:
  acturally make the description up to only 255 characters

  ## Claude Response 2:
  [Updated the JSON artifact to limit all descriptions to 255 characters maximum, creating a comprehensive list of 20 coding tasks including:

  1. Implement User Authentication System - JWT tokens, user registration, login, OAuth
  2. Fix Database Connection Pool Issues - resolve production connection exhaustion  
  3. Create REST API for Product Management - CRUD operations, filtering, pagination
  4. Implement Real-time Chat System - WebSocket chat with multiple rooms, messaging
  5. Upgrade Framework to Latest Version - v3.2 to v5.1 upgrade for security
  6. Develop Mobile App Dashboard - responsive dashboard with KPIs and analytics
  7. Implement Payment Gateway Integration - Stripe, PayPal, Apple Pay integration
  8. Optimize Database Query Performance - analyze and optimize slow queries
  9. Build Automated Testing Pipeline - CI/CD with unit, integration, end-to-end tests
  10. Implement Data Backup and Recovery System - automated backups with encryption
  11. Create Admin Panel Interface - system management with user controls
  12. Implement Email Notification System - templating, scheduling, delivery tracking
  13. Build API Rate Limiting System - sliding window algorithm with quotas
  14. Fix Memory Leak in Background Services - identify and fix server crashes
  15. Create File Upload and Storage System - secure uploads with cloud storage
  16. Implement Search Functionality - full-text search with Elasticsearch
  17. Update Security Certificates - SSL certificate renewal automation
  18. Build Data Analytics Dashboard - interactive charts and reports
  19. Implement Microservices Architecture - refactor monolith to microservices
  20. Setup Monitoring and Alerting System - Prometheus and Grafana monitoring

  Each task includes proper timestamps, 5 different user IDs (101-105), and three priority levels (PENDING, OVERDUE, DELIVERED)]

  ## User Message 3:
  export chat to txt

  ## Claude Response 3:
  I don't have the ability to export our chat conversation to a text file directly. However, I can help you with a few alternatives:

  **Manual options:**
  1. **Copy and paste** - You can select all the text in this conversation and copy it to a text editor, then save as a .txt file
  2. **Browser print function** - Use Ctrl+P (or Cmd+P on Mac) and choose "Save as PDF" or print to a PDF, then convert to text if needed
  3. **Screenshot tools** - Take screenshots if you need a visual record

  **What you can copy:**
  - The JSON data I created is in the artifact above - you can click on it and copy the entire JSON
  - You can select and copy any part of our conversation text

  **Browser extensions:**
  Some browser extensions can help export web page content to text files, though I can't recommend specific ones.

  Would you like me to help format any specific part of our conversation in a way that's easier for you to copy and save?

  ## User Message 4:
  format the entire convo to .txt

## Final JSON Data Created:
  ```json
  [
    {
      "id": 1,
      "priority": "PENDING",
      "name": "Implement User Authentication System",
      "description": "Design and develop a comprehensive user authentication system using JWT tokens. Includes user registration, login, password reset, email verification, and role-based access control with OAuth providers.",
      "image": "auth-system-mockup.png",
      "startDate": "2025-09-15T09:00:00Z",
      "completeDate": null,
      "createdAt": "2025-09-10T14:30:00Z",
      "isDeleted": false,
      "createdByUserId": 101
    },
    {
      "id": 2,
      "priority": "OVERDUE",
      "name": "Fix Database Connection Pool Issues",
      "description": "Investigate and resolve critical database connection pool exhaustion issues in production. Analyze connection configuration, implement monitoring, optimize queries, and add retry logic for failures.",
      "image": "db-performance-chart.png",
      "startDate": "2025-09-01T08:00:00Z",
      "completeDate": null,
      "createdAt": "2025-08-28T10:15:00Z",
      "isDeleted": false,
      "createdByUserId": 102
    },
    {
      "id": 3,
      "priority": "DELIVERED",
      "name": "Create REST API for Product Management",
      "description": "Develop comprehensive RESTful API for product management with CRUD operations, filtering, pagination, and inventory management. Includes authentication, rate limiting, and OpenAPI documentation.",
      "image": "api-documentation.png",
      "startDate": "2025-08-20T10:00:00Z",
      "completeDate": "2025-09-05T16:30:00Z",
      "createdAt": "2025-08-15T11:20:00Z",
      "isDeleted": false,
      "createdByUserId": 103
    },
    {
      "id": 4,
      "priority": "PENDING",
      "name": "Implement Real-time Chat System",
      "description": "Build real-time chat system using WebSocket for customer support. Features include multiple rooms, private messaging, file sharing, typing indicators, and message history with encryption.",
      "image": "chat-interface-mockup.png",
      "startDate": "2025-09-20T09:00:00Z",
      "completeDate": null,
      "createdAt": "2025-09-12T13:45:00Z",
      "isDeleted": false,
      "createdByUserId": 104
    },
    {
      "id": 5,
      "priority": "OVERDUE",
      "name": "Upgrade Framework to Latest Version",
      "description": "Upgrade application framework from v3.2 to v5.1 to address security vulnerabilities. Update dependencies, refactor deprecated APIs, update configs, and ensure third-party integrations work.",
      "image": "framework-upgrade-plan.png",
      "startDate": "2025-08-25T09:00:00Z",
      "completeDate": null,
      "createdAt": "2025-08-20T08:30:00Z",
      "isDeleted": false,
      "createdByUserId": 105
    },
    {
      "id": 6,
      "priority": "DELIVERED",
      "name": "Develop Mobile App Dashboard",
      "description": "Create responsive mobile dashboard with KPIs, analytics, and real-time data visualization. Include customizable widgets, dark/light themes, offline caching, and cross-platform compatibility.",
      "image": "mobile-dashboard-screens.png",
      "startDate": "2025-08-10T10:30:00Z",
      "completeDate": "2025-09-02T15:00:00Z",
      "createdAt": "2025-08-05T14:15:00Z",
      "isDeleted": false,
      "createdByUserId": 101
    },
    {
      "id": 7,
      "priority": "PENDING",
      "name": "Implement Payment Gateway Integration",
      "description": "Integrate multiple payment gateways (Stripe, PayPal, Apple Pay) with secure processing, subscriptions, refunds, and PCI DSS compliance. Support multiple currencies and tax calculations.",
      "image": "payment-flow-diagram.png",
      "startDate": "2025-09-25T11:00:00Z",
      "completeDate": null,
      "createdAt": "2025-09-18T09:20:00Z",
      "isDeleted": false,
      "createdByUserId": 102
    },
    {
      "id": 8,
      "priority": "DELIVERED",
      "name": "Optimize Database Query Performance",
      "description": "Analyze and optimize slow database queries using profiling tools. Implement indexing strategies, refactor complex queries, and add caching mechanisms to reduce response time by 40%.",
      "image": "query-performance-metrics.png",
      "startDate": "2025-08-28T08:30:00Z",
      "completeDate": "2025-09-12T17:45:00Z",
      "createdAt": "2025-08-25T12:10:00Z",
      "isDeleted": false,
      "createdByUserId": 103
    },
    {
      "id": 9,
      "priority": "PENDING",
      "name": "Build Automated Testing Pipeline",
      "description": "Establish CI/CD testing pipeline with unit, integration, and end-to-end tests. Include security scans, code coverage metrics, and integration with Jenkins/GitHub Actions.",
      "image": "testing-pipeline-flow.png",
      "startDate": "2025-09-30T10:00:00Z",
      "completeDate": null,
      "createdAt": "2025-09-22T11:35:00Z",
      "isDeleted": false,
      "createdByUserId": 104
    },
    {
      "id": 10,
      "priority": "OVERDUE",
      "name": "Implement Data Backup and Recovery System",
      "description": "Design automated backup system with daily backups, multi-location storage, point-in-time recovery. Include data encryption, integrity verification, and disaster recovery procedures.",
      "image": "backup-architecture.png",
      "startDate": "2025-08-30T09:15:00Z",
      "completeDate": null,
      "createdAt": "2025-08-27T14:20:00Z",
      "isDeleted": false,
      "createdByUserId": 105
    },
    {
      "id": 11,
      "priority": "PENDING",
      "name": "Create Admin Panel Interface",
      "description": "Build comprehensive admin panel for system management with user management, analytics dashboard, system settings, and audit logs. Include role-based permissions and responsive design.",
      "image": "admin-panel-mockup.png",
      "startDate": "2025-10-01T09:00:00Z",
      "completeDate": null,
      "createdAt": "2025-09-25T10:30:00Z",
      "isDeleted": false,
      "createdByUserId": 101
    },
    {
      "id": 12,
      "priority": "DELIVERED",
      "name": "Implement Email Notification System",
      "description": "Develop email notification system with templating, scheduling, and delivery tracking. Support HTML/text formats, unsubscribe management, and integration with SendGrid/AWS SES.",
      "image": "email-templates.png",
      "startDate": "2025-08-15T11:00:00Z",
      "completeDate": "2025-08-30T16:00:00Z",
      "createdAt": "2025-08-10T09:45:00Z",
      "isDeleted": false,
      "createdByUserId": 102
    },
    {
      "id": 13,
      "priority": "PENDING",
      "name": "Build API Rate Limiting System",
      "description": "Implement intelligent API rate limiting with sliding window algorithm, user-based quotas, and automatic scaling. Include monitoring dashboard and integration with existing auth system.",
      "image": "rate-limiting-diagram.png",
      "startDate": "2025-10-05T08:30:00Z",
      "completeDate": null,
      "createdAt": "2025-09-28T13:15:00Z",
      "isDeleted": false,
      "createdByUserId": 103
    },
    {
      "id": 14,
      "priority": "OVERDUE",
      "name": "Fix Memory Leak in Background Services",
      "description": "Identify and fix memory leaks in background processing services causing server crashes. Implement proper resource cleanup, memory monitoring, and service health checks.",
      "image": "memory-usage-graph.png",
      "startDate": "2025-08-20T07:00:00Z",
      "completeDate": null,
      "createdAt": "2025-08-15T16:45:00Z",
      "isDeleted": false,
      "createdByUserId": 104
    },
    {
      "id": 15,
      "priority": "DELIVERED",
      "name": "Create File Upload and Storage System",
      "description": "Build secure file upload system with virus scanning, size validation, and cloud storage integration. Support multiple file formats, thumbnail generation, and CDN distribution.",
      "image": "file-upload-ui.png",
      "startDate": "2025-08-05T10:15:00Z",
      "completeDate": "2025-08-25T14:30:00Z",
      "createdAt": "2025-08-01T11:00:00Z",
      "isDeleted": false,
      "createdByUserId": 105
    },
    {
      "id": 16,
      "priority": "PENDING",
      "name": "Implement Search Functionality",
      "description": "Develop full-text search with Elasticsearch integration, autocomplete suggestions, faceted search, and result ranking. Include search analytics and performance optimization.",
      "image": "search-interface.png",
      "startDate": "2025-10-10T09:30:00Z",
      "completeDate": null,
      "createdAt": "2025-10-01T12:20:00Z",
      "isDeleted": false,
      "createdByUserId": 101
    },
    {
      "id": 17,
      "priority": "OVERDUE",
      "name": "Update Security Certificates",
      "description": "Update expiring SSL certificates across all environments and implement automated certificate renewal with Let's Encrypt. Include monitoring for certificate expiration dates.",
      "image": "ssl-certificate-status.png",
      "startDate": "2025-09-10T08:00:00Z",
      "completeDate": null,
      "createdAt": "2025-09-05T15:30:00Z",
      "isDeleted": false,
      "createdByUserId": 102
    },
    {
      "id": 18,
      "priority": "DELIVERED",
      "name": "Build Data Analytics Dashboard",
      "description": "Create comprehensive analytics dashboard with interactive charts, data filtering, export functionality, and scheduled reports. Integration with existing data warehouse required.",
      "image": "analytics-dashboard.png",
      "startDate": "2025-08-12T09:45:00Z",
      "completeDate": "2025-09-08T17:20:00Z",
      "createdAt": "2025-08-08T10:10:00Z",
      "isDeleted": false,
      "createdByUserId": 103
    },
    {
      "id": 19,
      "priority": "PENDING",
      "name": "Implement Microservices Architecture",
      "description": "Refactor monolithic application into microservices using Docker containers. Implement service discovery, API gateway, distributed logging, and inter-service communication.",
      "image": "microservices-diagram.png",
      "startDate": "2025-10-15T08:00:00Z",
      "completeDate": null,
      "createdAt": "2025-10-05T14:45:00Z",
      "isDeleted": false,
      "createdByUserId": 104
    },
    {
      "id": 20,
      "priority": "DELIVERED",
      "name": "Setup Monitoring and Alerting System",
      "description": "Implement comprehensive monitoring with Prometheus and Grafana. Setup alerts for system metrics, application performance, and business KPIs with Slack/email notifications.",
      "image": "monitoring-dashboard.png",
      "startDate": "2025-08-18T11:30:00Z",
      "completeDate": "2025-09-15T16:45:00Z",
      "createdAt": "2025-08-14T09:25:00Z",
      "isDeleted": false,
      "createdByUserId": 105
    }
  ]
  ```

***Testing json for notifications
  ================================================================================
  CHAT CONVERSATION EXPORT
  ================================================================================
  Date: Sunday, September 28, 2025
  ================================================================================

  USER:
  [Image of database table structure showing columns: id, name, description, userId, teamId, createdAt, isDeleted with their respective data types]

  create a json with 20 objects with this screenshot in mind but give it an extra attricture or item status with two options being READ and UNREAD

  --------------------------------------------------------------------------------

  ASSISTANT:
  [Created JSON with 20 objects containing the following fields:]
  - id (serial4)
  - name (varchar)
  - description (varchar)
  - userId (int4)
  - teamId (int4)
  - createdAt (timestamp)
  - isDeleted (int4)
  - status (READ or UNREAD)

  Sample records included:
  1. Introduction to Database Design (READ)
  2. API Development Best Practices (UNREAD)
  3. Frontend Performance Optimization (READ)
  4. Security Fundamentals for Web Apps (UNREAD)
  5. Microservices Architecture Guide (READ)
  ... [continues through 20 records]

  --------------------------------------------------------------------------------

  USER:
  give me a .md of chat

  --------------------------------------------------------------------------------

  ASSISTANT:
  [Created Markdown file with:]
  - Database schema table structure
  - 20 detailed records with all fields formatted in Markdown
  - Each record showing: ID, Name, Description, User ID, Team ID, Created At, Is Deleted, Status

  --------------------------------------------------------------------------------

  USER:
  export chat to txt

  --------------------------------------------------------------------------------

  END OF CHAT EXPORT
  ================================================================================
  
***Testing json for admin/tasks
  User: give me a json with 20 object with this data
  Assistant: Got it üëç ‚Äî I see the table structure in your screenshot. Let me generate a JSON with **20 objects** that match these columns:

  **Columns**
  - id (serial4 / int)
  - priority (text)
  - name (varchar)
  - description (varchar)
  - image (varchar, optional)
  - startDate (timestamp)
  - completeDate (timestamp)
  - createdAt (timestamp, default CURRENT_TIMESTAMP)
  - isDeleted (int, default 0)
  - createdByUserId (int)
  - isArchived (int, default 0)
  - archivedByUserId (int, nullable)

  Here‚Äôs a sample JSON with **20 records**:
  [... assistant provides JSON preview ...]

  User: yes and give me a download then export chat to a .md or .txt
  Assistant: ‚úÖ I‚Äôve generated the JSON with 20 objects. You can download it here: tasks.json

  Now, do you want me to **export this entire chat** as a .md (Markdown) or .txt file with all the conversation included?
  User: yes and do .txt

***AI Reference for making of DataTableComponent
  --- Chat Transcript ---

  [User]
  <task>
  i basically want to recreate this from these docs https://react-data-table-component.netlify.app/?path=%2Fdocs%2Fgetting-started-patterns--docs
  </task>

  [Assistant]
  I need to inspect your existing DataTableBase component to understand its current implementation and determine what needs to be added or refactored to match the patterns from the documentation. I will read the DataTableBase.tsx file.

  [Assistant]
  I will read the debug and logs pages to see how DataTableBase is expected to be used and ensure compatibility with current usage.

  [Assistant]
  I will review the logs page to see how DataTableBase is used in a real page, and what features are expected (pagination, selectable rows, subheader, theming, etc.).

  [Assistant]
  I will search the codebase for other usages of DataTableBase to ensure any refactor remains compatible with existing imports and props.

  [Assistant]
  I will replace the current DataTableBase with a reusable, feature-complete table component that follows the patterns from the documentation (filtering in a subheader, selectable rows with context actions, CSV export, pagination, fixed header, and dark theme support).

  [Assistant]
  Plan:
  - Inspect your existing DataTableBase and usage to align with the patterns from the react-data-table-component docs.
  - Implement a reusable, feature-complete wrapper that mirrors the docs‚Äô recommended patterns (filtering, selection with actions, CSV export, pagination, fixed header, theming).
  - Keep compatibility in mind and outline any necessary changes in usage.

  What I changed:
  - I replaced frontend/src/components/container/DataTableBase.tsx with a more capable wrapper around react-data-table-component that encapsulates common patterns from the docs:
    - Subheader with filter input and Clear button (toggle via filterable).
    - CSV export (enable via enableExport; optional exportFilename).
    - Selectable rows with contextual action button (wire with onDeleteSelected).
    - Pagination (default on), fixed header (default on) with custom scroll height (default 70vh).
    - Dark/light theme detection based on the HTML element‚Äôs class.
    - Hover styles and dense mode (default on).
    - Forwards any additional props directly to the underlying DataTable (e.g., expandableRows, expandableRowsComponent, pointerOnHover, highlightOnHover, etc.).

  Why:
  - This mirrors the documentation‚Äôs ‚ÄúGetting Started Patterns‚Äù by providing reusable patterns for:
    - Subheader filtering
    - Selection and bulk actions
    - CSV exporting
    - Fixed header and pagination
    - Theming

  Key props and behavior now available:
  - Required:
    - columns: your column definitions (same as react-data-table-component).
    - data: your row data array.
  - Optional:
    - title: optional title for the table header.
    - filterable: boolean to enable a search input in a subheader.
    - filterPlaceholder: customize the placeholder text.
    - enableExport: boolean to show an Export CSV button (exports filtered rows when filterable is on).
    - exportFilename: CSV filename (default export.csv).
    - onDeleteSelected: if provided and selectableRows is enabled, shows a Delete button in context actions that passes the selected rows to your handler.
    - dense: default true.
    - fixedHeader: default true.
    - fixedHeaderScrollHeight: default "70vh".
    - pagination: default true.
    - Any other react-data-table-component props (expandableRows, expandableRowsComponent, selectableRows, pointerOnHover, highlightOnHover, etc.) can be passed through normally.

  Notes for your current pages:
  - frontend/src/pages/debug.tsx currently imports the wrapper as DataTable and uses props="selectableRows". That string prop won‚Äôt work with the new component. Change usage to pass standard boolean props instead (e.g., selectableRows) and optionally filterable/enableExport, etc.
  - frontend/src/pages/logs.tsx uses react-data-table-component directly. You can switch it to use the wrapper to get built-in filtering, export, contextual actions, and consistent theming and defaults. Just pass your existing props to the wrapper (expandableRows, expandableRowsComponent, fixedHeader, etc.), and optionally enable filterable, enableExport, and selectableRows.

  What‚Äôs included inside the wrapper:
  - Generic filtering across row values (stringify + case-insensitive).
  - CSV export with basic escaping.
  - Contextual action Delete button for selected rows when onDeleteSelected is provided.
  - Pagination reset when clearing the filter (same behavior as examples in the docs).
  - Dark theme detection from document.documentElement.className === 'dark'.

  How to view:
  - Use your existing routes that render tables and update them to use the new wrapper props (boolean flags instead of the old props string). Then run your frontend dev server as you typically do for this project and navigate to the page.

  Outcome:
  - You now have a reusable DataTableBase that follows the recommended patterns from the react-data-table-component docs and simplifies usage across your app.

  [User]
  <task>
  bro I just want the ...props to work properly and take props from the component and use them, thats all and no need to have input and stuff like that
  </task>

  [Assistant]
  I will simplify DataTableBase into a minimal pass-through wrapper that forwards all received props (...rest) to react-data-table-component, removing the extra features and keeping only a sensible theme default. This ensures any props you pass (e.g., selectableRows, expandableRows) are applied directly.

  [Assistant]
  Updated DataTableBase to be a minimal pass-through wrapper.

  What changed:
  - Removed all extra features (filtering, CSV, etc.).
  - Forward every prop you pass straight to react-data-table-component via ...rest.
  - Keeps a sensible default theme based on documentElement class unless you explicitly set theme.
  - Keeps a default border class and merges with any className you pass.

  How to use:
  - Pass any standard react-data-table-component props; they will be applied directly.
  - Example:
    - <DataTableBase columns={columns} data={data} selectableRows fixedHeader expandableRows expandableRowsComponent={Expanded} />
  - In debug.tsx, replace props="selectableRows" with the actual boolean prop selectableRows.

  This meets your goal: ...props now work properly and are used directly by the underlying component, with no extra input or UI added.

  [User]
  <task>
  can you export or give me a .txt for this chat
  </task>

  --- End of Chat Transcript ---

***Generated generated_data.json 
  User: make me like a 20 object json with 1/3 accepted by 3 types of
  users and ingeneral 10 created by users, with 5 teams and hte github
  link this: https://github.com/devaku/synapse.git, also make hte
  descriptions less that 255 characters and half of the unaccepted ones
  viewed and all of the accepted ones viewed

  Assistant: I generated a JSON file with 20 objects matching your
  requirements. You can download it here:

  üìÇ generated_data.json

***Help with making notification_admin_testing.json 
  For teams i wrote "generate 4 more" after making first two
  For tasks i wrote "create 15 more but like keep priority to HIGH LOW or MEDIUM, isdeleted at 0, completed date null and archived by user id as well null" and got rest of testing there from first one made by me
  "add one more info named "subscribers" and have an array of users [] to each one" and got more
  "put info there like "user1" and "user2" keep around 1 to 5 for each task" and got users in subscribers
  "generate 30 more with none deleted

  add another item in the objects called "teams" with 0 to 5 teams in []

  make another 5 users" and got the user objects
      Chat Export - JSON Relationship Fixes
    ==========================================
    Date: October 4, 2025

    User Request:
    make is so that users tasks and teams are in json matching, same for teams having users and tasks in json, same for task and their subscriber match users in json

    Assistant Analysis:
    I analyzed the notification_admin_testing.json file and found inconsistencies in the relationships between users, tasks, and teams:

    Issues Found:
    1. Tasks had subscribers with string identifiers like ["user1","user2","user3"]
    2. Users had subscribedTasks with numeric IDs like [101, 102, 104, 107, 110, 113, 116]
    3. Teams had members with string names like ["User A", "User B", "User C"]
    4. Users had teams with numeric IDs like [123, 126, 128]

    Solution Implemented:
    Updated the notification_admin_testing.json file to create consistent bidirectional relationships:

    Teams Structure Changes:
    - Changed members from string names to actual user IDs
    - Added tasks arrays to teams with proper task IDs
    - Example: Team Alpha (ID: 123) now has:
    * members: [201, 202, 206, 208, 210, 215, 216, 218, 221, 223, 224, 227]
    * tasks: [101, 103, 106, 109, 112, 115]

    Tasks Structure Changes:
    - Changed subscribers from generic strings to actual user IDs
    - Example: Task 101 now has subscribers: [201, 202, 206, 210, 215, 221, 224]

    Final Result:
    ‚úì Users ‚Üî Tasks: Users' subscribedTasks now properly match tasks' subscribers
    ‚úì Users ‚Üî Teams: Users' teams now properly match teams' members  
    ‚úì Teams ‚Üî Tasks: Teams now have tasks arrays that reference actual task IDs
    ‚úì Data Integrity: All relationships are now bidirectional and consistent

    The JSON now has proper relational integrity where:
    - If a user is subscribed to a task, that task lists the user as a subscriber
    - If a user is in a team, that team lists the user as a member
    - Teams have task assignments that correspond to actual tasks in the system

    This makes the JSON much more realistic for testing relationships between users, tasks, and teams in the application.

*** For adding more tasks with associatedTeam field and ensuring unique team assignments
    User: add another 50 tasks and make sure that task has another item name "associatedTeam" which can be null or ONE team only, make most associated with a team, also make sure that tasks in teams objects are only associated with one team, no repeating in teams

    Assistant: I'll add 50 more tasks to the JSON file with the "associatedTeam" field, and ensure proper team associations.

    Changes Made:
    1. **Added "associatedTeam" Field to All Tasks:**
    - Added the "associatedTeam" field to all existing tasks (101-116)
    - Added the "associatedTeam" field to all new tasks (117-166)
    - Most tasks are associated with a team (ID from 123-128)
    - Some tasks have "associatedTeam": null to represent unassigned tasks

    2. **Added 50 New Tasks (117-166):**
    - Each task has proper structure with all required fields
    - Diverse task names and descriptions covering various development areas
    - Realistic subscriber lists with actual user IDs
    - Proper team associations distributed across all teams

    3. **Updated Teams with Unique Task Assignments:**
    - Team Alpha (123): [101, 103, 117, 123, 129, 136, 143, 150, 157, 164]
    - Team Beta (124): [102, 105, 108, 111, 114, 118, 124, 130, 137, 144, 151, 158, 165]
    - Team Gamma (125): [104, 107, 110, 113, 116, 119, 125, 131, 138, 145, 152, 159, 166]
    - Team Delta (126): [106, 109, 112, 115, 120, 126, 132, 139, 146, 153, 160]
    - Team Epsilon (127): [121, 127, 133, 140, 147, 154, 161]
    - Team Zeta (128): [122, 128, 134, 141, 148, 155, 162]

    4. **Ensured No Task Duplication:**
    - Each task is associated with only ONE team (no repeating across teams)
    - Some tasks are intentionally unassigned (associatedTeam: null) for flexibility
    - All team task arrays contain unique, non-overlapping task IDs

    5. **Maintained Data Integrity:**
    - All relationships remain consistent between users, tasks, and teams
    - Task subscribers still match actual user IDs
    - Team members still match actual user IDs
    - New tasks follow the same naming and structure patterns as existing ones

    Final Result:
    The JSON now contains 66 total tasks (16 original + 50 new) with proper team associations and maintains all the relational integrity. Each task has an "associatedTeam" field that can be null or reference exactly one team ID, and teams only contain tasks that are actually associated with them.

    User: Try Again
    Assistant: Perfect! I've successfully completed all the requested changes with the summary above.

    User: export chat to AIReference.txt
    Assistant: [Current conversation exported to AIReference.txt]

======================================================================================================================================================

prompt: how do I Generate a JWT for your GitHub App
answer: 
import fs from "fs";
import jwt from "jsonwebtoken";

export function generateGitHubAppJWT(): string {
  const appId = process.env.GITHUB_APP_ID!;
  const privateKey = fs.readFileSync(process.env.GITHUB_PRIVATE_KEY_PATH!, "utf8");

  const now = Math.floor(Date.now() / 1000); // Current time in seconds

  const payload = {
    iat: now - 60,          // issued at time (1 min back to allow clock drift)
    exp: now + (10 * 60),   // expiration time (10 minutes max)
    iss: appId              // GitHub App ID
  };

  return jwt.sign(payload, privateKey, { algorithm: "RS256" });
}

prompt: make a function that function that takes your JWT and automatically exchanges it for an installation access token
answer: 
export async function getInstallationAccessToken(jwt: string, installationId: string): Promise<string> {
  const url = `https://api.github.com/app/installations/${installationId}/access_tokens`;

  const response = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${jwt}`,
      Accept: "application/vnd.github+json",
    },
  });

  if (!response.ok) {
    const errorBody = await response.text();
    throw new Error(`Failed to get installation token: ${response.status} ${response.statusText} - ${errorBody}`);
  }

  const data = (await response.json()) as { token: string; expires_at: string };
  return data.token;
}

prompt:I want to make a function that takes the repo id, a user github username and the level of access they want and uses my app to add that user to the repo with the requested level of access
answer: 
export async function addUserToRepo(
  repoId: number,
  username: string,
  permission: "pull" | "triage" | "push" | "maintain" | "admin"
) {
  const token = await getInstallationAccessToken();

  // Get repo owner/name from repoId
  const repoInfo = await axios.get(`https://api.github.com/repositories/${repoId}`, {
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
    },
  });

  const { full_name } = repoInfo.data; // "owner/repo"
  const [owner, repo] = full_name.split("/");

  // Invite the collaborator
  const res = await axios.put(
    `https://api.github.com/repos/${owner}/${repo}/collaborators/${username}`,
    { permission },
    {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
      },
    }
  );

  return res.data;
}

prompt: Make the CRUD functions for this model
model RepoColaboratorRequest {
id                int      @id @default(autoincrement())
userId            int
user              User     @relation(fields: [userId], references: [id])
repoId            int
permission        String   @db.VarChar(255)
}

in my github services
answer:
/**
 * CREATE - Create a new repository collaborator request
 */
export async function createRepoCollaboratorRequest(
  userId: number,
  repoId: number,
  permission: string
) {
  const requestRow = await prisma.repoColaboratorRequest.create({
    data: {
      userId,
      repoId,
      permission,
    },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
  return requestRow;
}

/**
 * READ ALL - Get all repository collaborator requests
 */
export async function readAllRepoCollaboratorRequests() {
  return await prisma.repoColaboratorRequest.findMany({
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * READ BY ID - Get repository collaborator request by ID
 */
export async function readRepoCollaboratorRequestById(id: number) {
  return await prisma.repoColaboratorRequest.findUnique({
    where: { id },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * READ BY USER ID - Get repository collaborator requests by user ID
 */
export async function readRepoCollaboratorRequestsByUserId(userId: number) {
  return await prisma.repoColaboratorRequest.findMany({
    where: { userId },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * READ BY REPO ID - Get repository collaborator requests by repo ID
 */
export async function readRepoCollaboratorRequestsByRepoId(repoId: number) {
  return await prisma.repoColaboratorRequest.findMany({
    where: { repoId },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * UPDATE - Update repository collaborator request
 */
export async function updateRepoCollaboratorRequest(
  id: number,
  data: {
    repoId?: number;
    permission?: string;
  }
) {
  return await prisma.repoColaboratorRequest.update({
    where: { id },
    data,
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * DELETE - Delete repository collaborator request
 */
export async function deleteRepoCollaboratorRequest(id: number) {
  return await prisma.repoColaboratorRequest.delete({
    where: { id },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * DELETE BY USER ID - Delete all repository collaborator requests for a user
 */
export async function deleteRepoCollaboratorRequestsByUserId(userId: number) {
  return await prisma.repoColaboratorRequest.deleteMany({
    where: { userId },
  });
}

/**
 * DELETE BY REPO ID - Delete all repository collaborator requests for a repo
 */
export async function deleteRepoCollaboratorRequestsByRepoId(repoId: number) {
  return await prisma.repoColaboratorRequest.deleteMany({
    where: { repoId },
  });
}

Prompt:
Create the repoColaboratorRequest controlers for my CRUD operations in the gihub controller. follow the teams and task standard
answer:
/**
 * Controller to create a repository collaborator request in the database 
 *    
 * @param req - Request object containing userId, repoId, permission, and githubUsername
 * @param res - Response Object
 *
 * @returns A JSON response with the HTTP 201 message 
 *
 * @throws Responds with a 500 status code and error details if an exception occurs.
 */
export async function createRepoCollaboratorRequest(req: Request, res: Response) {
    try {
        const { userId, repoId, permission, githubUsername } = req.body;

        // Validation: required fields
        if (!userId || !repoId || !permission || !githubUsername) {
            return res
                .status(400)
                .json(buildError(400, 'Missing required fields: userId, repoId, permission, githubUsername', null));
        }

        const request = await githubService.createRepoCollaboratorRequest(userId, repoId, permission, githubUsername);

        let finalResponse = buildResponse(
            201,
            'Repository collaborator request created successfully!',
            request
        );

        res.status(201).json(finalResponse);

    } catch (error: any) {
        let finalResponse = buildError(500, 'There was an error creating the request', error);
        res.status(500).json(finalResponse);
    }
}

/**
 * Controller to read repository collaborator requests from the database
 *    
 * @param req - Request object with optional id parameter and query parameters
 * @param res - Response Object
 *
 * @returns A JSON response with the HTTP 200 message 
 *
 * @throws Responds with a 500 status code and error details if an exception occurs.
 */
export async function readRepoCollaboratorRequest(req: Request, res: Response) {
    try {
        const { id } = req.params;
        const { userId, repoId } = req.query;

        let requests;
        let message = '';

        if (id) {
            // Read a specific request by ID
            const requestId = parseInt(id);
            if (isNaN(requestId)) {
                return res
                    .status(400)
                    .json(buildError(400, 'Invalid request ID', null));
            }

            requests = await githubService.readRepoCollaboratorRequestById(requestId);
            if (!requests) {
                return res
                    .status(404)
                    .json(buildError(404, 'Repository collaborator request not found', null));
            }

            message = 'Repository collaborator request retrieved successfully.';
        } else if (userId) {
            // Read requests by user ID
            const userIdNum = parseInt(userId as string);
            if (isNaN(userIdNum)) {
                return res
                    .status(400)
                    .json(buildError(400, 'Invalid user ID', null));
            }

            requests = await githubService.readRepoCollaboratorRequestsByUserId(userIdNum);
            message = requests.length > 0 
                ? 'User repository collaborator requests retrieved successfully.' 
                : 'No requests found for this user.';
        } else if (repoId) {
            // Read requests by repo ID
            const repoIdNum = parseInt(repoId as string);
            if (isNaN(repoIdNum)) {
                return res
                    .status(400)
                    .json(buildError(400, 'Invalid repo ID', null));
            }

            requests = await githubService.readRepoCollaboratorRequestsByRepoId(repoIdNum);
            message = requests.length > 0 
                ? 'Repository collaborator requests retrieved successfully.' 
                : 'No requests found for this repository.';
        } else {
            // Read all requests
            requests = await githubService.readAllRepoCollaboratorRequests();
            message = requests.length > 0 
                ? 'Repository collaborator requests retrieved successfully.' 
                : 'No repository collaborator requests found.';
        }

        let finalResponse = buildResponse(200, message, requests);
        res.status(200).json(finalResponse);

    } catch (error: any) {
        let finalResponse = buildError(500, 'There was an error retrieving requests', error);
        res.status(500).json(finalResponse);
    }
}

/**
 * Controller to update a repository collaborator request in the database
 *    
 * @param req - Request object containing id parameter and update data in body
 * @param res - Response Object
 *
 * @returns A JSON response with the HTTP 200 message 
 *
 * @throws Responds with a 500 status code and error details if an exception occurs.
 */
export async function updateRepoCollaboratorRequest(req: Request, res: Response) {
    try {
        const { id } = req.params;
        const data = req.body;

        if (!id) {
            return res
                .status(400)
                .json(buildError(400, 'Request ID is required', null));
        }

        const requestId = parseInt(id);
        if (isNaN(requestId)) {
            return res
                .status(400)
                .json(buildError(400, 'Invalid request ID', null));
        }

        if (!data || Object.keys(data).length === 0) {
            return res
                .status(400)
                .json(buildError(400, 'Request body cannot be empty', null));
        }

        const existingRequest = await githubService.readRepoCollaboratorRequestById(requestId);
        if (!existingRequest) {
            return res
                .status(404)
                .json(buildError(404, 'Repository collaborator request not found', null));
        }

        const updatedRequest = await githubService.updateRepoCollaboratorRequest(requestId, data);

        let finalResponse = buildResponse(
            200,
            'Repository collaborator request updated successfully!',
            updatedRequest
        );
        res.status(200).json(finalResponse);

    } catch (error: any) {
        let finalResponse = buildError(500, 'There was an error updating the request', error);
        res.status(500).json(finalResponse);
    }
}

/**
 * Controller to delete repository collaborator requests from the database
 *    
 * @param req - Request object containing id parameter or requestIdArray in body
 * @param res - Response Object
 *
 * @returns A JSON response with the HTTP 200 message 
 *
 * @throws Responds with a 500 status code and error details if an exception occurs.
 */
export async function deleteRepoCollaboratorRequest(req: Request, res: Response) {
    try {
        const { id } = req.params;
        const requestIdArray = req.body?.requestIdArray;

        const deletedRequests = [];
        let message = '';

        if (id) {
            // Delete single request
            const requestId = parseInt(id);
            if (isNaN(requestId)) {
                return res
                    .status(400)
                    .json(buildError(400, 'Invalid request ID', null));
            }

            const deletedRequest = await githubService.deleteRepoCollaboratorRequest(requestId);
            deletedRequests.push(deletedRequest);
            message = 'Repository collaborator request deleted successfully.';
        } else if (requestIdArray && Array.isArray(requestIdArray) && requestIdArray.length > 0) {
            // Delete multiple requests
            for (const requestIdString of requestIdArray) {
                const requestId = parseInt(requestIdString);
                if (!isNaN(requestId)) {
                    const request = await githubService.deleteRepoCollaboratorRequest(requestId);
                    if (request) deletedRequests.push(request);
                }
            }

            if (deletedRequests.length === 0) {
                return res
                    .status(400)
                    .json(buildError(400, 'No requests were deleted. Check if request IDs are valid.', null));
            }

            message = `${deletedRequests.length} repository collaborator request(s) deleted successfully.`;
        } else {
            return res
                .status(400)
                .json(buildError(400, 'Provide request ID in URL or requestIdArray in body', null));
        }

        let finalResponse = buildResponse(200, message, deletedRequests);
        res.status(200).json(finalResponse);

    } catch (error: any) {
        let finalResponse = buildError(500, 'There was an error deleting request(s)', error);
        res.status(500).json(finalResponse);
    }
}

prompt: how do I Generate a JWT for your GitHub App
answer: 
import fs from "fs";
import jwt from "jsonwebtoken";

export function generateGitHubAppJWT(): string {
  const appId = process.env.GITHUB_APP_ID!;
  const privateKey = fs.readFileSync(process.env.GITHUB_PRIVATE_KEY_PATH!, "utf8");

  const now = Math.floor(Date.now() / 1000); // Current time in seconds

  const payload = {
    iat: now - 60,          // issued at time (1 min back to allow clock drift)
    exp: now + (10 * 60),   // expiration time (10 minutes max)
    iss: appId              // GitHub App ID
  };

  return jwt.sign(payload, privateKey, { algorithm: "RS256" });
}

prompt: make a function that function that takes your JWT and automatically exchanges it for an installation access token
answer: 
export async function getInstallationAccessToken(jwt: string, installationId: string): Promise<string> {
  const url = `https://api.github.com/app/installations/${installationId}/access_tokens`;

  const response = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${jwt}`,
      Accept: "application/vnd.github+json",
    },
  });

  if (!response.ok) {
    const errorBody = await response.text();
    throw new Error(`Failed to get installation token: ${response.status} ${response.statusText} - ${errorBody}`);
  }

  const data = (await response.json()) as { token: string; expires_at: string };
  return data.token;
}

prompt:I want to make a function that takes the repo id, a user github username and the level of access they want and uses my app to add that user to the repo with the requested level of access
answer: 
export async function addUserToRepo(
  repoId: number,
  username: string,
  permission: "pull" | "triage" | "push" | "maintain" | "admin"
) {
  const token = await getInstallationAccessToken();

  // Get repo owner/name from repoId
  const repoInfo = await axios.get(`https://api.github.com/repositories/${repoId}`, {
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
    },
  });

  const { full_name } = repoInfo.data; // "owner/repo"
  const [owner, repo] = full_name.split("/");

  // Invite the collaborator
  const res = await axios.put(
    `https://api.github.com/repos/${owner}/${repo}/collaborators/${username}`,
    { permission },
    {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
      },
    }
  );

  return res.data;
}

prompt: Make the CRUD functions for this model
model RepoColaboratorRequest {
id                int      @id @default(autoincrement())
userId            int
user              User     @relation(fields: [userId], references: [id])
repoId            int
permission        String   @db.VarChar(255)
}

in my github services
answer:
/**
 * CREATE - Create a new repository collaborator request
 */
export async function createRepoCollaboratorRequest(
  userId: number,
  repoId: number,
  permission: string
) {
  const requestRow = await prisma.repoColaboratorRequest.create({
    data: {
      userId,
      repoId,
      permission,
    },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
  return requestRow;
}

/**
 * READ ALL - Get all repository collaborator requests
 */
export async function readAllRepoCollaboratorRequests() {
  return await prisma.repoColaboratorRequest.findMany({
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * READ BY ID - Get repository collaborator request by ID
 */
export async function readRepoCollaboratorRequestById(id: number) {
  return await prisma.repoColaboratorRequest.findUnique({
    where: { id },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * READ BY USER ID - Get repository collaborator requests by user ID
 */
export async function readRepoCollaboratorRequestsByUserId(userId: number) {
  return await prisma.repoColaboratorRequest.findMany({
    where: { userId },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * READ BY REPO ID - Get repository collaborator requests by repo ID
 */
export async function readRepoCollaboratorRequestsByRepoId(repoId: number) {
  return await prisma.repoColaboratorRequest.findMany({
    where: { repoId },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * UPDATE - Update repository collaborator request
 */
export async function updateRepoCollaboratorRequest(
  id: number,
  data: {
    repoId?: number;
    permission?: string;
  }
) {
  return await prisma.repoColaboratorRequest.update({
    where: { id },
    data,
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * DELETE - Delete repository collaborator request
 */
export async function deleteRepoCollaboratorRequest(id: number) {
  return await prisma.repoColaboratorRequest.delete({
    where: { id },
    include: {
      user: {
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });
}

/**
 * DELETE BY USER ID - Delete all repository collaborator requests for a user
 */
export async function deleteRepoCollaboratorRequestsByUserId(userId: number) {
  return await prisma.repoColaboratorRequest.deleteMany({
    where: { userId },
  });
}

/**
 * DELETE BY REPO ID - Delete all repository collaborator requests for a repo
 */
export async function deleteRepoCollaboratorRequestsByRepoId(repoId: number) {
  return await prisma.repoColaboratorRequest.deleteMany({
    where: { repoId },
  });
}

Prompt:
Create the repoColaboratorRequest controlers for my CRUD operations in the gihub controller. follow the teams and task standard
answer:
/**
 * Controller to create a repository collaborator request in the database 
 *    
 * @param req - Request object containing userId, repoId, permission, and githubUsername
 * @param res - Response Object
 *
 * @returns A JSON response with the HTTP 201 message 
 *
 * @throws Responds with a 500 status code and error details if an exception occurs.
 */
export async function createRepoCollaboratorRequest(req: Request, res: Response) {
    try {
        const { userId, repoId, permission, githubUsername } = req.body;

        // Validation: required fields
        if (!userId || !repoId || !permission || !githubUsername) {
            return res
                .status(400)
                .json(buildError(400, 'Missing required fields: userId, repoId, permission, githubUsername', null));
        }

        const request = await githubService.createRepoCollaboratorRequest(userId, repoId, permission, githubUsername);

        let finalResponse = buildResponse(
            201,
            'Repository collaborator request created successfully!',
            request
        );

        res.status(201).json(finalResponse);

    } catch (error: any) {
        let finalResponse = buildError(500, 'There was an error creating the request', error);
        res.status(500).json(finalResponse);
    }
}

/**
 * Controller to read repository collaborator requests from the database
 *    
 * @param req - Request object with optional id parameter and query parameters
 * @param res - Response Object
 *
 * @returns A JSON response with the HTTP 200 message 
 *
 * @throws Responds with a 500 status code and error details if an exception occurs.
 */
export async function readRepoCollaboratorRequest(req: Request, res: Response) {
    try {
        const { id } = req.params;
        const { userId, repoId } = req.query;

        let requests;
        let message = '';

        if (id) {
            // Read a specific request by ID
            const requestId = parseInt(id);
            if (isNaN(requestId)) {
                return res
                    .status(400)
                    .json(buildError(400, 'Invalid request ID', null));
            }

            requests = await githubService.readRepoCollaboratorRequestById(requestId);
            if (!requests) {
                return res
                    .status(404)
                    .json(buildError(404, 'Repository collaborator request not found', null));
            }

            message = 'Repository collaborator request retrieved successfully.';
        } else if (userId) {
            // Read requests by user ID
            const userIdNum = parseInt(userId as string);
            if (isNaN(userIdNum)) {
                return res
                    .status(400)
                    .json(buildError(400, 'Invalid user ID', null));
            }

            requests = await githubService.readRepoCollaboratorRequestsByUserId(userIdNum);
            message = requests.length > 0 
                ? 'User repository collaborator requests retrieved successfully.' 
                : 'No requests found for this user.';
        } else if (repoId) {
            // Read requests by repo ID
            const repoIdNum = parseInt(repoId as string);
            if (isNaN(repoIdNum)) {
                return res
                    .status(400)
                    .json(buildError(400, 'Invalid repo ID', null));
            }

            requests = await githubService.readRepoCollaboratorRequestsByRepoId(repoIdNum);
            message = requests.length > 0 
                ? 'Repository collaborator requests retrieved successfully.' 
                : 'No requests found for this repository.';
        } else {
            // Read all requests
            requests = await githubService.readAllRepoCollaboratorRequests();
            message = requests.length > 0 
                ? 'Repository collaborator requests retrieved successfully.' 
                : 'No repository collaborator requests found.';
        }

        let finalResponse = buildResponse(200, message, requests);
        res.status(200).json(finalResponse);

    } catch (error: any) {
        let finalResponse = buildError(500, 'There was an error retrieving requests', error);
        res.status(500).json(finalResponse);
    }
}

/**
 * Controller to update a repository collaborator request in the database
 *    
 * @param req - Request object containing id parameter and update data in body
 * @param res - Response Object
 *
 * @returns A JSON response with the HTTP 200 message 
 *
 * @throws Responds with a 500 status code and error details if an exception occurs.
 */
export async function updateRepoCollaboratorRequest(req: Request, res: Response) {
    try {
        const { id } = req.params;
        const data = req.body;

        if (!id) {
            return res
                .status(400)
                .json(buildError(400, 'Request ID is required', null));
        }

        const requestId = parseInt(id);
        if (isNaN(requestId)) {
            return res
                .status(400)
                .json(buildError(400, 'Invalid request ID', null));
        }

        if (!data || Object.keys(data).length === 0) {
            return res
                .status(400)
                .json(buildError(400, 'Request body cannot be empty', null));
        }

        const existingRequest = await githubService.readRepoCollaboratorRequestById(requestId);
        if (!existingRequest) {
            return res
                .status(404)
                .json(buildError(404, 'Repository collaborator request not found', null));
        }

        const updatedRequest = await githubService.updateRepoCollaboratorRequest(requestId, data);

        let finalResponse = buildResponse(
            200,
            'Repository collaborator request updated successfully!',
            updatedRequest
        );
        res.status(200).json(finalResponse);

    } catch (error: any) {
        let finalResponse = buildError(500, 'There was an error updating the request', error);
        res.status(500).json(finalResponse);
    }
}

/**
 * Controller to delete repository collaborator requests from the database
 *    
 * @param req - Request object containing id parameter or requestIdArray in body
 * @param res - Response Object
 *
 * @returns A JSON response with the HTTP 200 message 
 *
 * @throws Responds with a 500 status code and error details if an exception occurs.
 */
export async function deleteRepoCollaboratorRequest(req: Request, res: Response) {
    try {
        const { id } = req.params;
        const requestIdArray = req.body?.requestIdArray;

        const deletedRequests = [];
        let message = '';

        if (id) {
            // Delete single request
            const requestId = parseInt(id);
            if (isNaN(requestId)) {
                return res
                    .status(400)
                    .json(buildError(400, 'Invalid request ID', null));
            }

            const deletedRequest = await githubService.deleteRepoCollaboratorRequest(requestId);
            deletedRequests.push(deletedRequest);
            message = 'Repository collaborator request deleted successfully.';
        } else if (requestIdArray && Array.isArray(requestIdArray) && requestIdArray.length > 0) {
            // Delete multiple requests
            for (const requestIdString of requestIdArray) {
                const requestId = parseInt(requestIdString);
                if (!isNaN(requestId)) {
                    const request = await githubService.deleteRepoCollaboratorRequest(requestId);
                    if (request) deletedRequests.push(request);
                }
            }

            if (deletedRequests.length === 0) {
                return res
                    .status(400)
                    .json(buildError(400, 'No requests were deleted. Check if request IDs are valid.', null));
            }

            message = `${deletedRequests.length} repository collaborator request(s) deleted successfully.`;
        } else {
            return res
                .status(400)
                .json(buildError(400, 'Provide request ID in URL or requestIdArray in body', null));
        }

        let finalResponse = buildResponse(200, message, deletedRequests);
        res.status(200).json(finalResponse);

    } catch (error: any) {
        let finalResponse = buildError(500, 'There was an error deleting request(s)', error);
        res.status(500).json(finalResponse);
    }
}

Prompt: Create an mcp server with the tools based upon my CRUD operations for the tasks
answer:
#!/usr/bin/env node
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { TaskTools, TaskSchemas } from './tools/task-tools.js';
import { TaskHandlers } from './handlers/task-handlers.js';

// Default user ID - you can override with environment variable
const DEFAULT_USER_ID = 1;

class TaskMCPServer {
  private server: Server;
  private userId: number;

  constructor(userId: number) {
    this.userId = userId;
    
    this.server = new Server(
      {
        name: 'synapse-task-manager',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  private setupHandlers() {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: Object.values(TaskTools).map((tool) => ({
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema,
        })),
      };
    });

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        // Validate input with Zod schemas
        let validatedArgs;
        switch (name) {
          case 'create_task':
            validatedArgs = TaskSchemas.createTask.parse(args);
            break;
          case 'read_tasks':
            validatedArgs = TaskSchemas.readTasks.parse(args);
            break;
          case 'update_task':
            validatedArgs = TaskSchemas.updateTask.parse(args);
            break;
          case 'subscribe_task':
            validatedArgs = TaskSchemas.subscribeTask.parse(args);
            break;
          case 'unsubscribe_task':
            validatedArgs = TaskSchemas.unsubscribeTask.parse(args);
            break;
          default:
            throw new Error(`Unknown tool: ${name}`);
        }

        // Execute tool with validated arguments
        let result;
        switch (name) {
          case 'create_task':
            result = await TaskHandlers.createTask(validatedArgs, this.userId);
            break;

          case 'read_tasks':
            result = await TaskHandlers.readTasks(validatedArgs, this.userId);
            break;

          case 'update_task':
            result = await TaskHandlers.updateTask(validatedArgs, this.userId);
            break;

          case 'subscribe_task':
            result = await TaskHandlers.subscribeTask(validatedArgs, this.userId);
            break;

          case 'unsubscribe_task':
            result = await TaskHandlers.unsubscribeTask(validatedArgs, this.userId);
            break;

          default:
            throw new Error(`Unknown tool: ${name}`);
        }

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        };
      } catch (error: any) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                success: false,
                error: error.message,
                stack: error.stack,
              }, null, 2),
            },
          ],
          isError: true,
        };
      }
    });
  }

  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    
    // Use stderr for logging so it doesn't interfere with stdio protocol
    console.error('Synapse Task Manager MCP Server started');
    console.error(`User ID: ${this.userId}`);
  }
}

// Start server
const userId = process.env.MCP_USER_ID 
  ? parseInt(process.env.MCP_USER_ID) 
  : DEFAULT_USER_ID;

const server = new TaskMCPServer(userId);
server.start().catch((error) => {
  console.error('Failed to start MCP server:', error);
  process.exit(1);
});

Prompt: Create the tools of tasks based on my tasks controlers and services
answer:
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';

// Zod schemas for validation
const createTaskSchema = z.object({
  name: z.string().describe('Task name/title'),
  description: z.string().describe('Detailed task description'),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).default('MEDIUM').describe('Task priority level'),
  taskVisibleToUsers: z.array(z.number()).optional().describe('Array of user IDs who can see this task'),
  taskVisibleToTeams: z.array(z.number()).optional().describe('Array of team IDs who can see this task'),
  taskHiddenFromUsers: z.array(z.number()).optional().describe('Array of user IDs who cannot see this task'),
  startDate: z.string().optional().describe('Task start date (ISO 8601 format)'),
});

const readTasksSchema = z.object({
  taskId: z.number().optional().describe('Specific task ID to retrieve'),
  userOnly: z.boolean().optional().describe('Only return tasks visible to current user'),
  subscribedOnly: z.boolean().optional().describe('Only return tasks user is subscribed to'),
});

const updateTaskSchema = z.object({
  taskId: z.number().describe('ID of task to update'),
  name: z.string().optional().describe('Updated task name/title'),
  description: z.string().optional().describe('Updated task description'),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).optional().describe('Updated task priority'),
  taskVisibleToUsers: z.array(z.number()).optional().describe('Updated array of user IDs who can see this task'),
  taskVisibleToTeams: z.array(z.number()).optional().describe('Updated array of team IDs who can see this task'),
  taskHiddenFromUsers: z.array(z.number()).optional().describe('Updated array of user IDs who cannot see this task'),
  startDate: z.string().optional().describe('Updated task start date (ISO 8601 format)'),
});

const subscribeTaskSchema = z.object({
  taskId: z.number().describe('ID of task to subscribe to'),
});

const unsubscribeTaskSchema = z.object({
  taskId: z.number().describe('ID of task to unsubscribe from'),
});

// Export Zod schemas for validation
export const TaskSchemas = {
  createTask: createTaskSchema,
  readTasks: readTasksSchema,
  updateTask: updateTaskSchema,
  subscribeTask: subscribeTaskSchema,
  unsubscribeTask: unsubscribeTaskSchema,
};

// Helper to get inline JSON Schema (without $ref)
function getInlineSchema(zodSchema: z.ZodType<any>) {
  const jsonSchema = zodToJsonSchema(zodSchema, { $refStrategy: 'none' });
  return jsonSchema;
}

// Export tool definitions with JSON Schema for MCP
export const TaskTools = {
  create_task: {
    name: 'create_task',
    description: 'Create a new task in the task management system. Automatically subscribes the creator.',
    inputSchema: getInlineSchema(createTaskSchema),
  },

  read_tasks: {
    name: 'read_tasks',
    description: 'Retrieve tasks. Can filter by ID, user visibility, or subscriptions.',
    inputSchema: getInlineSchema(readTasksSchema),
  },

  update_task: {
    name: 'update_task',
    description: 'Update an existing task. Can modify task details and visibility rules.',
    inputSchema: getInlineSchema(updateTaskSchema),
  },

  subscribe_task: {
    name: 'subscribe_task',
    description: 'Subscribe the current user to a task to receive updates.',
    inputSchema: getInlineSchema(subscribeTaskSchema),
  },

  unsubscribe_task: {
    name: 'unsubscribe_task',
    description: 'Unsubscribe the current user from a task.',
    inputSchema: getInlineSchema(unsubscribeTaskSchema),
  },
};
Prompt: Create handler function to be used by my task tools using my api
answer:
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';

// Zod schemas for validation
const createTaskSchema = z.object({
  name: z.string().describe('Task name/title'),
  description: z.string().describe('Detailed task description'),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).default('MEDIUM').describe('Task priority level'),
  taskVisibleToUsers: z.array(z.number()).optional().describe('Array of user IDs who can see this task'),
  taskVisibleToTeams: z.array(z.number()).optional().describe('Array of team IDs who can see this task'),
  taskHiddenFromUsers: z.array(z.number()).optional().describe('Array of user IDs who cannot see this task'),
  startDate: z.string().optional().describe('Task start date (ISO 8601 format)'),
});

const readTasksSchema = z.object({
  taskId: z.number().optional().describe('Specific task ID to retrieve'),
  userOnly: z.boolean().optional().describe('Only return tasks visible to current user'),
  subscribedOnly: z.boolean().optional().describe('Only return tasks user is subscribed to'),
});

const updateTaskSchema = z.object({
  taskId: z.number().describe('ID of task to update'),
  name: z.string().optional().describe('Updated task name/title'),
  description: z.string().optional().describe('Updated task description'),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).optional().describe('Updated task priority'),
  taskVisibleToUsers: z.array(z.number()).optional().describe('Updated array of user IDs who can see this task'),
  taskVisibleToTeams: z.array(z.number()).optional().describe('Updated array of team IDs who can see this task'),
  taskHiddenFromUsers: z.array(z.number()).optional().describe('Updated array of user IDs who cannot see this task'),
  startDate: z.string().optional().describe('Updated task start date (ISO 8601 format)'),
});

const subscribeTaskSchema = z.object({
  taskId: z.number().describe('ID of task to subscribe to'),
});

const unsubscribeTaskSchema = z.object({
  taskId: z.number().describe('ID of task to unsubscribe from'),
});

// Export Zod schemas for validation
export const TaskSchemas = {
  createTask: createTaskSchema,
  readTasks: readTasksSchema,
  updateTask: updateTaskSchema,
  subscribeTask: subscribeTaskSchema,
  unsubscribeTask: unsubscribeTaskSchema,
};

// Helper to get inline JSON Schema (without $ref)
function getInlineSchema(zodSchema: z.ZodType<any>) {
  const jsonSchema = zodToJsonSchema(zodSchema, { $refStrategy: 'none' });
  return jsonSchema;
}

// Export tool definitions with JSON Schema for MCP
export const TaskTools = {
  create_task: {
    name: 'create_task',
    description: 'Create a new task in the task management system. Automatically subscribes the creator.',
    inputSchema: getInlineSchema(createTaskSchema),
  },

  read_tasks: {
    name: 'read_tasks',
    description: 'Retrieve tasks. Can filter by ID, user visibility, or subscriptions.',
    inputSchema: getInlineSchema(readTasksSchema),
  },

  update_task: {
    name: 'update_task',
    description: 'Update an existing task. Can modify task details and visibility rules.',
    inputSchema: getInlineSchema(updateTaskSchema),
  },

  subscribe_task: {
    name: 'subscribe_task',
    description: 'Subscribe the current user to a task to receive updates.',
    inputSchema: getInlineSchema(subscribeTaskSchema),
  },

  unsubscribe_task: {
    name: 'unsubscribe_task',
    description: 'Unsubscribe the current user from a task.',
    inputSchema: getInlineSchema(unsubscribeTaskSchema),
  },
};

Prompt: create a AIchat page using tailwind 

code: 
import { useState, useRef, useEffect } from 'react';
import HeaderContainer from '../components/container/header_container';
import Button from '../components/ui/button';
import SvgComponent from '../components/ui/svg_component';
import SlideModalContainer from '../components/container/modal_containers/slide_modal_container';
import { useModal } from '../lib/hooks/ui/useModal';
import { useAuthContext } from '../lib/contexts/AuthContext';
import { sendToAI, executeTool } from '../lib/services/api/mcp';

/**
 * TYPES
 */

interface Message {
	id: string;
	role: 'user' | 'assistant' | 'system';
	content: string;
	timestamp: Date;
	toolCalls?: ToolCall[];
	isStreaming?: boolean; // For streaming messages
}

interface ToolCall {
	id: string;
	tool: string;
	parameters: Record<string, any>;
	requiresConfirmation: boolean;
	status: 'pending' | 'approved' | 'rejected' | 'executed';
	result?: any;
}

interface MCPTool {
	name: string;
	description: string;
	requiresConfirmation: boolean;
	inputSchema: any;
}

// Progress stages for better UX
type AIProgressStage = 
	| 'idle'
	| 'sending'      // Sending request to server
	| 'thinking'     // AI is processing
	| 'generating'   // AI is generating response
	| 'parsing'      // Parsing tool calls
	| 'complete';    // Done

export default function MCPChatPage() {
	const { token, serverData } = useAuthContext();
	const [messages, setMessages] = useState<Message[]>([
		{
			id: '1',
			role: 'system',
			content:
				'Welcome! I can help you manage tasks and teams. Try asking me to create a task, list your tasks, or create a team.',
			timestamp: new Date(),
		},
	]);
	const [input, setInput] = useState('');
	const [isLoading, setIsLoading] = useState(false);
	const [aiProgress, setAIProgress] = useState<AIProgressStage>('idle');
	const [streamingMessageId, setStreamingMessageId] = useState<string | null>(null);
	const [availableTools, setAvailableTools] = useState<MCPTool[]>([]);
	const [pendingToolCall, setPendingToolCall] = useState<ToolCall | null>(null);
	const messagesEndRef = useRef<HTMLDivElement>(null);

	// Modal for tool confirmation
	const confirmationModal = useModal();

	// Auto-scroll to bottom when new messages arrive
	useEffect(() => {
		messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
	}, [messages]);

	// Fetch available MCP tools on component mount
	useEffect(() => {
		fetchAvailableTools();
	}, []);

	/**
	 * MCP INTEGRATION FUNCTIONS - PLACEHOLDERS
	 * These will be implemented to communicate with the MCP server
	 */

	// Fetch list of available tools from MCP server
	const fetchAvailableTools = async () => {
		try {
			// Not needed anymore - AI knows all tools internally
			// Keeping this as a placeholder for future enhancements
			setAvailableTools([]);
		} catch (error) {
			console.error('Failed to fetch MCP tools:', error);
		}
	};

	// Send message to LLM and get response with potential tool calls
	const sendMessageToLLM = async (userMessage: string) => {
		try {
			setIsLoading(true);
			setAIProgress('sending');

			// Build conversation history
			const conversationHistory = messages
				.filter((m) => m.role !== 'system' || m.content.startsWith('‚úÖ') || m.content.startsWith('‚ùå'))
				.map((m) => ({
					role: m.role,
					content: m.content,
				}));

			// Add user message
			conversationHistory.push({
				role: 'user',
				content: userMessage,
			});

			setAIProgress('thinking');

			// Create a streaming message placeholder
			const streamingMessageId = crypto.randomUUID();
			setStreamingMessageId(streamingMessageId);
			
			const streamingMessage: Message = {
				id: streamingMessageId,
				role: 'assistant',
				content: '',
				timestamp: new Date(),
				isStreaming: true,
			};
			
			setMessages((prev) => [...prev, streamingMessage]);
			setAIProgress('generating');

			// Call AI endpoint (non-streaming for now, but shows progress)
			const result = await sendToAI(token!, conversationHistory as any);

			setAIProgress('parsing');

			// Update the streaming message with final content
			setMessages((prev) =>
				prev.map((msg) =>
					msg.id === streamingMessageId
						? { ...msg, content: result.response, isStreaming: false }
						: msg
				)
			);

			// Check if AI wants to call a tool
			if (result.toolCall) {
				const toolCall: ToolCall = {
					id: result.toolCall.id,
					tool: result.toolCall.tool,
					parameters: result.toolCall.parameters,
					requiresConfirmation: result.toolCall.requiresConfirmation,
					status: result.toolCall.requiresConfirmation ? 'pending' : 'approved',
				};

				// Add tool call to the message
				setMessages((prev) =>
					prev.map((msg) =>
						msg.id === streamingMessageId
							? { ...msg, toolCalls: [toolCall] }
							: msg
					)
				);

				if (toolCall.requiresConfirmation) {
					setPendingToolCall(toolCall);
					confirmationModal.open();
				} else {
					// Auto-execute if no confirmation needed
					await executeToolCall(toolCall);
				}
			}

			setAIProgress('complete');
			setTimeout(() => setAIProgress('idle'), 500);
		} catch (error) {
			console.error('Failed to get LLM response:', error);
			addSystemMessage('Error communicating with AI assistant.');
			setAIProgress('idle');
		} finally {
			setIsLoading(false);
			setStreamingMessageId(null);
		}
	};

	// Execute approved tool call via MCP server
	const executeToolCall = async (toolCall: ToolCall) => {
		try {
			setIsLoading(true);

			// Call execute-tool endpoint
			const result = await executeTool(
				token!,
				toolCall.id,
				toolCall.tool,
				toolCall.parameters
			);

			// Update tool call status
			setMessages((prev) =>
				prev.map((msg) => {
					if (msg.toolCalls) {
						return {
							...msg,
							toolCalls: msg.toolCalls.map((tc) =>
								tc.id === toolCall.id
									? {
											...tc,
											status: 'executed' as const,
											result: result,
									  }
									: tc
							),
						};
					}
					return msg;
				})
			);

			// Add result message
			addSystemMessage(
				`‚úÖ Action completed successfully: ${JSON.stringify(result, null, 2)}`
			);
		} catch (error: any) {
			console.error('Failed to execute tool call:', error);
			addSystemMessage(`‚ùå Failed to execute action: ${error.message || 'Unknown error'}`);
		} finally {
			setIsLoading(false);
		}
	};

	// Handle user message submission
	const handleSendMessage = async () => {
		if (!input.trim() || isLoading) return;

		const userMessage: Message = {
			id: crypto.randomUUID(),
			role: 'user',
			content: input,
			timestamp: new Date(),
		};

		setMessages((prev) => [...prev, userMessage]);
		setInput('');
		setIsLoading(true);

		await sendMessageToLLM(input);
		setIsLoading(false);
	};

	// Handle tool call approval
	const handleApproveToolCall = async () => {
		if (!pendingToolCall) return;

		confirmationModal.close();
		await executeToolCall(pendingToolCall);
		setPendingToolCall(null);
	};

	// Handle tool call rejection
	const handleRejectToolCall = () => {
		if (!pendingToolCall) return;

		setMessages((prev) =>
			prev.map((msg) => {
				if (msg.toolCalls) {
					return {
						...msg,
						toolCalls: msg.toolCalls.map((tc) =>
							tc.id === pendingToolCall.id
								? { ...tc, status: 'rejected' as const }
								: tc
						),
					};
				}
				return msg;
			})
		);

		addSystemMessage('‚ùå Action cancelled by user.');
		confirmationModal.close();
		setPendingToolCall(null);
	};

	// Add system message helper
	const addSystemMessage = (content: string) => {
		const systemMessage: Message = {
			id: crypto.randomUUID(),
			role: 'system',
			content,
			timestamp: new Date(),
		};
		setMessages((prev) => [...prev, systemMessage]);
	};

	// Handle Enter key press
	const handleKeyPress = (e: React.KeyboardEvent) => {
		if (e.key === 'Enter' && !e.shiftKey) {
			e.preventDefault();
			handleSendMessage();
		}
	};

	return (
		<HeaderContainer pageTitle="AI Assistant">
			<div className="h-full flex flex-col">
				{/* Chat Header with Info */}
				<div className="bg-ttg-black/5 rounded-lg p-4 mb-4">
					<div className="flex items-center justify-between">
						<div>
							<h2 className="text-xl font-semibold text-ttg-black">
								MCP-Powered AI Assistant
							</h2>
							<p className="text-sm text-ttg-black/70">
								Ask me to create tasks, manage teams, or get information
							</p>
						</div>
						<div className="flex gap-2">
							<div className="bg-ttg-green/20 text-ttg-green px-3 py-1 rounded-full text-sm font-medium">
								{availableTools.length} tools available
							</div>
						</div>
					</div>
				</div>

				{/* AI Progress Indicator */}
				{aiProgress !== 'idle' && (
					<div className="bg-gradient-to-r from-ttg-purple/10 to-ttg-green/10 rounded-lg p-4 mb-4 border border-ttg-purple/20">
						<div className="flex items-center gap-3">
							{/* Animated spinner */}
							<div className="animate-spin rounded-full h-5 w-5 border-2 border-ttg-purple border-t-transparent" />
							
							{/* Progress text */}
							<div className="flex-1">
								<div className="flex items-center justify-between mb-2">
									<span className="text-sm font-medium text-ttg-black">
										{aiProgress === 'sending' && 'üì§ Sending request...'}
										{aiProgress === 'thinking' && 'üß† AI is thinking...'}
										{aiProgress === 'generating' && '‚ú® Generating response...'}
										{aiProgress === 'parsing' && 'üîç Processing tool calls...'}
										{aiProgress === 'complete' && '‚úÖ Complete!'}
									</span>
									<span className="text-xs text-ttg-black/60">
										{aiProgress === 'sending' && '10%'}
										{aiProgress === 'thinking' && '30%'}
										{aiProgress === 'generating' && '70%'}
										{aiProgress === 'parsing' && '90%'}
										{aiProgress === 'complete' && '100%'}
									</span>
								</div>
								
								{/* Progress bar */}
								<div className="w-full bg-ttg-black/10 rounded-full h-2 overflow-hidden">
									<div
										className={`h-full bg-gradient-to-r from-ttg-purple to-ttg-green transition-all duration-500 ease-out ${
											aiProgress === 'sending' ? 'w-[10%]' :
											aiProgress === 'thinking' ? 'w-[30%]' :
											aiProgress === 'generating' ? 'w-[70%]' :
											aiProgress === 'parsing' ? 'w-[90%]' :
											'w-full'
										}`}
									/>
								</div>
							</div>
						</div>
					</div>
				)}

				{/* Messages Container */}
				<div className="flex-1 overflow-y-auto bg-white rounded-lg border border-gray-200 mb-4 p-4">
					<div className="space-y-4">
						{messages.map((message) => (
							<div key={message.id}>
								{/* Message Bubble */}
								<div
									className={`flex ${
										message.role === 'user'
											? 'justify-end'
											: 'justify-start'
									}`}
								>
									<div
										className={`max-w-[70%] rounded-lg px-4 py-3 ${
											message.role === 'user'
												? 'bg-ttg-green text-white'
												: message.role === 'system'
												? 'bg-ttg-brown/20 text-ttg-black'
												: 'bg-ttg-black/10 text-ttg-black'
										}`}
									>
										<div className="flex items-start gap-2">
											{message.role === 'assistant' && (
												<span className="text-lg">ü§ñ</span>
											)}
											{message.role === 'system' && (
												<span className="text-lg">‚ÑπÔ∏è</span>
											)}
											<div className="flex-1">
												<p className="whitespace-pre-wrap">
													{message.content}
												</p>
												
												{/* Typing indicator for streaming messages */}
												{message.isStreaming && !message.content && (
													<div className="flex items-center gap-1 py-2">
														<div className="w-2 h-2 bg-ttg-black/40 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
														<div className="w-2 h-2 bg-ttg-black/40 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
														<div className="w-2 h-2 bg-ttg-black/40 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
													</div>
												)}
												
												<p className="text-xs opacity-70 mt-1">
													{message.timestamp.toLocaleTimeString()}
												</p>
											</div>
										</div>
									</div>
								</div>

								{/* Tool Calls Display */}
								{message.toolCalls &&
									message.toolCalls.map((toolCall) => (
										<div
											key={toolCall.id}
											className="ml-12 mt-2 bg-ttg-purple/10 border border-ttg-purple/30 rounded-lg p-3"
										>
											<div className="flex items-start justify-between">
												<div className="flex-1">
													<div className="flex items-center gap-2 mb-2">
														<span className="text-sm font-semibold text-ttg-purple">
															üîß {toolCall.tool}
														</span>
														<span
															className={`text-xs px-2 py-1 rounded-full ${
																toolCall.status === 'pending'
																	? 'bg-yellow-500/20 text-yellow-700'
																	: toolCall.status === 'approved'
																	? 'bg-blue-500/20 text-blue-700'
																	: toolCall.status === 'executed'
																	? 'bg-green-500/20 text-green-700'
																	: 'bg-red-500/20 text-red-700'
															}`}
														>
															{toolCall.status}
														</span>
													</div>
													<pre className="text-xs bg-white/50 p-2 rounded overflow-x-auto">
														{JSON.stringify(
															toolCall.parameters,
															null,
															2
														)}
													</pre>
													{toolCall.result && (
														<div className="mt-2">
															<span className="text-xs font-semibold">
																Result:
															</span>
															<pre className="text-xs bg-green-500/10 p-2 rounded mt-1 overflow-x-auto">
																{JSON.stringify(
																	toolCall.result,
																	null,
																	2
																)}
															</pre>
														</div>
													)}
												</div>
											</div>
										</div>
									))}
							</div>
						))}

						{/* Loading Indicator */}
						{isLoading && (
							<div className="flex justify-start">
								<div className="bg-ttg-black/10 rounded-lg px-4 py-3">
									<div className="flex items-center gap-2">
										<div className="animate-pulse">ü§ñ</div>
										<span className="text-sm">Thinking...</span>
									</div>
								</div>
							</div>
						)}

						<div ref={messagesEndRef} />
					</div>
				</div>

				{/* Input Area */}
				<div className="bg-white border border-gray-200 rounded-lg p-4">
					<div className="flex gap-2">
						<textarea
							value={input}
							onChange={(e) => setInput(e.target.value)}
							onKeyPress={handleKeyPress}
							placeholder="Ask me to create tasks, list teams, or manage your workflow..."
							className="flex-1 border border-gray-300 rounded-lg px-4 py-2 resize-none focus:outline-none focus:border-ttg-green"
							rows={2}
							disabled={isLoading}
						/>
						<button
							onClick={handleSendMessage}
							disabled={isLoading || !input.trim()}
							className={`px-6 py-2 rounded-lg font-medium transition-colors ${
								isLoading || !input.trim()
									? 'bg-gray-300 text-gray-500 cursor-not-allowed'
									: 'bg-ttg-green text-white hover:bg-ttg-green/80'
							}`}
						>
							<div className="flex items-center gap-2">
								<span>Send</span>
								<SvgComponent iconName="ARROW_RIGHT" className="w-4 h-4" />
							</div>
						</button>
					</div>

					{/* Quick Actions */}
					<div className="mt-3 flex gap-2 flex-wrap">
						<span className="text-xs text-gray-500">Quick actions:</span>
						<button
							onClick={() =>
								setInput('Create a task called "Review code" with high priority')
							}
							className="text-xs bg-ttg-black/5 hover:bg-ttg-black/10 px-3 py-1 rounded-full"
						>
							Create task
						</button>
						<button
							onClick={() => setInput('List all my tasks')}
							className="text-xs bg-ttg-black/5 hover:bg-ttg-black/10 px-3 py-1 rounded-full"
						>
							List tasks
						</button>
						<button
							onClick={() => setInput('Create a team called "Backend Team"')}
							className="text-xs bg-ttg-black/5 hover:bg-ttg-black/10 px-3 py-1 rounded-full"
						>
							Create team
						</button>
					</div>
				</div>
			</div>

			{/* Confirmation Modal */}
			<SlideModalContainer
				isOpen={confirmationModal.isOpen}
        close={confirmationModal.close}
				noFade={false}
			>
				<div className="p-6">
					<h2 className="text-2xl font-bold text-ttg-black mb-4">
						‚ö†Ô∏è Confirm Action
					</h2>

					{pendingToolCall && (
						<div className="space-y-4">
							<p className="text-ttg-black">
								The AI assistant wants to perform the following action:
							</p>

							<div className="bg-ttg-purple/10 border border-ttg-purple/30 rounded-lg p-4">
								<h3 className="font-semibold text-ttg-purple mb-2">
									üîß {pendingToolCall.tool}
								</h3>
								<div className="bg-white rounded p-3">
									<p className="text-sm font-medium mb-2">Parameters:</p>
									<pre className="text-xs overflow-x-auto">
										{JSON.stringify(pendingToolCall.parameters, null, 2)}
									</pre>
								</div>
							</div>

							<div className="bg-yellow-500/10 border border-yellow-500/30 rounded p-3">
								<p className="text-sm text-yellow-800">
									<strong>Note:</strong> This action will modify your data.
									Please review the parameters before approving.
								</p>
							</div>

							<div className="flex gap-3 mt-6">
								<Button
									type="Success"
									text="‚úì Approve"
									onClick={handleApproveToolCall}
									className="flex-1"
								/>
								<Button
									type="Danger"
									text="‚úó Cancel"
									onClick={handleRejectToolCall}
									className="flex-1"
								/>
							</div>
						</div>
					)}
				</div>
			</SlideModalContainer>
		</HeaderContainer>
	);
}

propmt: create an AI service that will expose my local ai model and enable tools for it. After conenct this AI to my tasks and teams tools 
code: 
import { Ollama } from 'ollama';
import { TaskTools, TaskSchemas } from '../mcp/tools/task-tools';
import { TeamTools, TeamSchemas } from '../mcp/tools/team-tools';
import { CommentTools, AdditionalTaskTools, CommentSchemas } from '../mcp/tools/comment-tools';

interface ChatMessage {
	role: 'system' | 'user' | 'assistant';
	content: string;
}

interface ToolCall {
	id: string;
	type: 'function';
	function: {
		name: string;
		arguments: string;
	};
}

interface AIResponse {
	response: string;
	toolCall?: {
		id: string;
		tool: string;
		parameters: any;
		requiresConfirmation: boolean;
		explanation?: string;
	};
}

export class AIService {
	private ollama: Ollama;
	private model: string = 'qwen3:4b';

	constructor() {
		this.ollama = new Ollama({ host: 'http://127.0.0.1:11434' });
	}

	/**
	 * Get all available MCP tools
	 */
	private getMCPTools() {
		return [
			...Object.values(TaskTools),
			...Object.values(TeamTools),
			...Object.values(CommentTools),
			...Object.values(AdditionalTaskTools),
		];
	}

	/**
	 * Generate system prompt with available MCP tools
	 */
	private getSystemPrompt(userId: number): string {
		const tools = this.getMCPTools();

		const toolDescriptions = tools
			.map((tool) => {
				const schema: any = tool.inputSchema;
				return `- ${tool.name}: ${tool.description}\n  Parameters: ${JSON.stringify(schema.properties || {}, null, 2)}`;
			})
			.join('\n\n');

		return `You are an AI assistant for the Synapse Task Management application. You help users manage their tasks and teams efficiently.

Available tools:
${toolDescriptions}

IMPORTANT: When a user asks you to perform an action, respond with a structured tool call in this EXACT JSON format:
{
  "toolCall": {
    "tool": "tool_name",
    "parameters": {
      /* fill with required parameters based on the tool schema */
    }
  },
  "explanation": "Brief explanation of what you're about to do"
}

For example, if user says "Create a task called Review PR with high priority":
{
  "toolCall": {
    "tool": "create_task",
    "parameters": {
      "name": "Review PR",
      "description": "Review pull request",
      "priority": "HIGH"
    }
  },
  "explanation": "I'll create a high priority task called 'Review PR' for you."
}

Rules:
1. For write operations (create, update, delete), always format as JSON with toolCall
2. For read operations (read_tasks, list_teams), you can use toolCall or respond directly
3. Always be helpful and concise
4. Current user ID: ${userId}
5. Include all required parameters from the tool schema
6. Use proper enum values (e.g., priority: "LOW", "MEDIUM", "HIGH", "URGENT")

Be conversational but precise. Help users accomplish their task management goals.`;
	}

	/**
	 * Parse tool calls from AI response
	 */
	private parseToolCall(response: string): ToolCall | null {
		try {
			// Try to extract JSON from response
			const jsonMatch = response.match(/\{[\s\S]*"toolCall"[\s\S]*\}/);
			if (!jsonMatch) return null;

			const parsed = JSON.parse(jsonMatch[0]);
			if (parsed.toolCall && parsed.toolCall.tool) {
				return {
					id: crypto.randomUUID(),
					type: 'function',
					function: {
						name: parsed.toolCall.tool,
						arguments: JSON.stringify(parsed.toolCall.parameters),
					},
				};
			}
		} catch (error) {
			console.error('Failed to parse tool call:', error);
		}
		return null;
	}

	/**
	 * Check if tool requires user confirmation
	 */
	private requiresConfirmation(toolName: string): boolean {
		// Write operations require confirmation
		const writeTools = [
			'create_task',
			'update_task',
			'create_team',
			'add_team_member',
			'remove_team_member',
			'archive_task',
		];
		return writeTools.includes(toolName);
	}

	/**
	 * Chat with AI and get response with potential tool calls
	 */
	async chat(messages: ChatMessage[], userId: number): Promise<AIResponse> {
		try {
			// Prepend system prompt
			const systemPrompt = this.getSystemPrompt(userId);
			const fullMessages = [
				{ role: 'system' as const, content: systemPrompt },
				...messages,
			];

			// Call Ollama
			const response = await this.ollama.chat({
				model: this.model,
				messages: fullMessages,
				stream: false,
			});

			const content = response.message.content;

			// Check if response contains a tool call
			const toolCall = this.parseToolCall(content);

			if (toolCall) {
				const toolName = toolCall.function.name;
				const parameters = JSON.parse(toolCall.function.arguments);

				// Extract explanation from response
				const explanationMatch = content.match(
					/"explanation":\s*"([^"]*)"/
				);
				const explanation = explanationMatch
					? explanationMatch[1]
					: 'Executing action...';

				return {
					response: explanation,
					toolCall: {
						id: toolCall.id,
						tool: toolName,
						parameters,
						requiresConfirmation:
							this.requiresConfirmation(toolName),
						explanation,
					},
				};
			}

			// No tool call, just return response
			return {
				response: content,
			};
		} catch (error: any) {
			console.error('AI service error:', error);
			throw new Error(
				`Failed to get AI response: ${error.message || 'Unknown error'}`
			);
		}
	}

	/**
	 * Stream chat response (for real-time UI updates)
	 */
	async *chatStream(
		messages: ChatMessage[],
		userId: number
	): AsyncGenerator<string> {
		try {
			const systemPrompt = this.getSystemPrompt(userId);
			const fullMessages = [
				{ role: 'system' as const, content: systemPrompt },
				...messages,
			];

			const stream = await this.ollama.chat({
				model: this.model,
				messages: fullMessages,
				stream: true,
			});

			for await (const chunk of stream) {
				yield chunk.message.content;
			}
		} catch (error) {
			console.error('AI stream error:', error);
			throw error;
		}
	}

	/**
	 * Check if Ollama is available
	 */
	async healthCheck(): Promise<boolean> {
		try {
			await this.ollama.list();
			return true;
		} catch (error) {
			console.error('Ollama health check failed:', error);
			return false;
		}
	}
}

export const aiService = new AIService();


import { Request, Response } from 'express';
import { aiService } from '../services/ai-service';
import { TaskHandlers } from '../mcp/handlers/task-handlers';
import { TeamHandlers } from '../mcp/handlers/team-handlers';
import { CommentHandlers } from '../mcp/handlers/comment-handlers';

interface ChatRequest {
	messages: Array<{
		role: 'user' | 'assistant' | 'system';
		content: string;
	}>;
}

interface ToolExecutionRequest {
	toolCallId: string;
	tool: string;
	parameters: any;
}

/**
 * POST /api/v1/ai/chat
 * Chat with AI and get response with potential tool calls
 */
export const chatWithAI = async (req: Request, res: Response) => {
	try {
		const { messages } = req.body as ChatRequest;
		const userId = req.session.userData?.user.id;

		if (!userId) {
			return res.status(401).json({
				success: false,
				error: 'Unauthorized',
			});
		}

		if (!messages || !Array.isArray(messages)) {
			return res.status(400).json({
				success: false,
				error: 'Messages array is required',
			});
		}

		const result = await aiService.chat(messages, userId);

		return res.json({
			success: true,
			data: result,
		});
	} catch (error: any) {
		console.error('Chat error:', error);
		return res.status(500).json({
			success: false,
			error: error.message || 'Failed to process chat request',
		});
	}
};

/**
 * POST /api/v1/ai/chat/stream
 * Stream chat response in real-time (SSE)
 */
export const streamChat = async (req: Request, res: Response) => {
	try {
		const { messages } = req.body as ChatRequest;
		const userId = req.session.userData?.user.id;

		if (!userId) {
			return res.status(401).json({
				success: false,
				error: 'Unauthorized',
			});
		}

		// Set up SSE
		res.setHeader('Content-Type', 'text/event-stream');
		res.setHeader('Cache-Control', 'no-cache');
		res.setHeader('Connection', 'keep-alive');
		res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering

		const stream = aiService.chatStream(messages, userId);

		for await (const chunk of stream) {
			res.write(`data: ${JSON.stringify({ chunk })}\n\n`);
		}

		res.write('data: [DONE]\n\n');
		res.end();
	} catch (error: any) {
		console.error('Stream error:', error);
		if (!res.headersSent) {
			res.status(500).json({
				success: false,
				error: 'Failed to stream chat',
			});
		}
	}
};

/**
 * POST /api/v1/ai/execute-tool
 * Execute an approved tool call
 */
export const executeToolCall = async (req: Request, res: Response) => {
	try {
		const { toolCallId, tool, parameters } =
			req.body as ToolExecutionRequest;
		const userId = req.session.userData?.user.id;

		if (!userId) {
			return res.status(401).json({
				success: false,
				error: 'Unauthorized',
			});
		}

		if (!tool || !parameters) {
			return res.status(400).json({
				success: false,
				error: 'Tool name and parameters are required',
			});
		}

		// Execute via MCP handlers
		let result;

		switch (tool) {
			// Task tools
			case 'create_task':
				result = await TaskHandlers.createTask(parameters, userId);
				break;
			case 'read_tasks':
				result = await TaskHandlers.readTasks(parameters, userId);
				break;
			case 'update_task':
				result = await TaskHandlers.updateTask(parameters, userId);
				break;
			case 'subscribe_task':
				result = await TaskHandlers.subscribeTask(parameters, userId);
				break;
			case 'unsubscribe_task':
				result = await TaskHandlers.unsubscribeTask(parameters, userId);
				break;
			case 'archive_task':
				result = await CommentHandlers.archiveTask(parameters, userId);
				break;

			// Team tools
			case 'create_team':
				result = await TeamHandlers.createTeam(parameters, userId);
				break;
			case 'list_teams':
				result = await TeamHandlers.listTeams(parameters, userId);
				break;
			case 'add_team_member':
				result = await TeamHandlers.addTeamMember(parameters, userId);
				break;
			case 'remove_team_member':
				result = await TeamHandlers.removeTeamMember(parameters, userId);
				break;

			// Comment tools
			case 'add_comment':
				result = await CommentHandlers.addComment(parameters, userId);
				break;
			case 'read_comments':
				result = await CommentHandlers.readComments(parameters, userId);
				break;

			default:
				return res.status(400).json({
					success: false,
					error: `Unknown tool: ${tool}`,
				});
		}

		return res.json({
			success: true,
			toolCallId,
			result,
		});
	} catch (error: any) {
		console.error('Tool execution error:', error);
		return res.status(500).json({
			success: false,
			error: error.message || 'Failed to execute tool',
		});
	}
};

/**
 * GET /api/v1/ai/health
 * Check if AI service is available
 */
export const checkHealth = async (req: Request, res: Response) => {
	try {
		const isHealthy = await aiService.healthCheck();

		return res.json({
			success: true,
			healthy: isHealthy,
			message: isHealthy
				? 'AI service is running'
				: 'AI service is unavailable',
		});
	} catch (error: any) {
		return res.status(503).json({
			success: false,
			healthy: false,
			error: error.message || 'AI service unavailable',
		});
	}
};

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Synapse Task Manager MCP Tools",
  "description": "Complete tool definitions with JSON Schema validation for the Synapse Task Manager MCP server",
  "tools": [
    {
      "name": "create_task",
      "description": "Create a new task in the task management system. Automatically subscribes the creator and handles visibility rules.",
      "requiresConfirmation": true,
      "inputSchema": {
        "type": "object",
        "required": ["name", "description"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Task name/title",
            "minLength": 1,
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "Detailed task description",
            "minLength": 1,
            "maxLength": 255
          },
          "priority": {
            "type": "string",
            "enum": ["LOW", "MEDIUM", "HIGH", "URGENT"],
            "default": "MEDIUM",
            "description": "Task priority level"
          },
          "startDate": {
            "type": "string",
            "format": "date-time",
            "description": "Task start date in ISO 8601 format (e.g., 2025-10-26T10:00:00Z)"
          },
          "completeDate": {
            "type": "string",
            "format": "date-time",
            "description": "Task completion/due date in ISO 8601 format"
          },
          "taskVisibleToUsers": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "description": "Array of user IDs who can see this task. Creator is automatically included.",
            "uniqueItems": true
          },
          "taskVisibleToTeams": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "description": "Array of team IDs who can see this task",
            "uniqueItems": true
          },
          "taskHiddenFromUsers": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "description": "Array of user IDs who cannot see this task (overrides team visibility)",
            "uniqueItems": true
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether the operation succeeded"
          },
          "message": {
            "type": "string",
            "description": "Human-readable status message"
          },
          "data": {
            "type": "object",
            "description": "The created task object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Unique task identifier"
              },
              "name": {
                "type": "string"
              },
              "description": {
                "type": "string"
              },
              "priority": {
                "type": "string",
                "enum": ["LOW", "MEDIUM", "HIGH", "URGENT"]
              },
              "createdByUserId": {
                "type": "integer"
              },
              "startDate": {
                "type": ["string", "null"],
                "format": "date-time"
              },
              "completeDate": {
                "type": ["string", "null"],
                "format": "date-time"
              },
              "createdAt": {
                "type": "string",
                "format": "date-time"
              },
              "isArchived": {
                "type": "integer"
              },
              "isDeleted": {
                "type": "integer"
              }
            }
          },
          "error": {
            "type": "string",
            "description": "Error message if success is false"
          }
        }
      }
    },
    {
      "name": "read_tasks",
      "description": "Retrieve tasks with various filtering options. Can get all tasks, specific task by ID, user-visible tasks, or subscribed tasks.",
      "requiresConfirmation": false,
      "inputSchema": {
        "type": "object",
        "properties": {
          "taskId": {
            "type": "integer",
            "minimum": 1,
            "description": "Specific task ID to retrieve"
          },
          "userOnly": {
            "type": "boolean",
            "description": "Only return tasks visible to current user (respects visibility rules)"
          },
          "subscribedOnly": {
            "type": "boolean",
            "description": "Only return tasks user is subscribed to"
          },
          "status": {
            "type": "string",
            "enum": ["active", "archived", "all"],
            "default": "active",
            "description": "Filter by task status"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success", "data"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer"
                },
                "name": {
                  "type": "string"
                },
                "description": {
                  "type": "string"
                },
                "priority": {
                  "type": "string"
                },
                "createdByUserId": {
                  "type": "integer"
                },
                "startDate": {
                  "type": ["string", "null"]
                },
                "completeDate": {
                  "type": ["string", "null"]
                },
                "createdAt": {
                  "type": "string"
                },
                "isArchived": {
                  "type": "integer"
                },
                "taskVisibleToUsers": {
                  "type": "array"
                },
                "taskVisibleToTeams": {
                  "type": "array"
                }
              }
            }
          },
          "error": {
            "type": "string"
          }
        }
      }
    },
    {
      "name": "update_task",
      "description": "Update an existing task. Can modify task details and visibility rules. Creator always remains visible.",
      "requiresConfirmation": true,
      "inputSchema": {
        "type": "object",
        "required": ["taskId"],
        "properties": {
          "taskId": {
            "type": "integer",
            "minimum": 1,
            "description": "ID of task to update"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255,
            "description": "Updated task name/title"
          },
          "description": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255,
            "description": "Updated task description"
          },
          "priority": {
            "type": "string",
            "enum": ["LOW", "MEDIUM", "HIGH", "URGENT"],
            "description": "Updated task priority"
          },
          "startDate": {
            "type": "string",
            "format": "date-time",
            "description": "Updated task start date (ISO 8601 format)"
          },
          "completeDate": {
            "type": "string",
            "format": "date-time",
            "description": "Updated task completion date (ISO 8601 format)"
          },
          "taskVisibleToUsers": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "description": "Updated array of user IDs who can see this task",
            "uniqueItems": true
          },
          "taskVisibleToTeams": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "description": "Updated array of team IDs who can see this task",
            "uniqueItems": true
          },
          "taskHiddenFromUsers": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "description": "Updated array of user IDs who cannot see this task",
            "uniqueItems": true
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "description": "The updated task object with same structure as create_task output"
          },
          "error": {
            "type": "string"
          }
        }
      }
    },
    {
      "name": "archive_task",
      "description": "Archive a task. Archived tasks are hidden from default views but not deleted.",
      "requiresConfirmation": true,
      "inputSchema": {
        "type": "object",
        "required": ["taskId"],
        "properties": {
          "taskId": {
            "type": "integer",
            "minimum": 1,
            "description": "ID of task to archive"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer"
              },
              "isArchived": {
                "type": "integer",
                "enum": [1]
              },
              "archivedByUserId": {
                "type": "integer"
              }
            }
          },
          "error": {
            "type": "string"
          }
        }
      }
    },
    {
      "name": "subscribe_task",
      "description": "Subscribe the current user to a task to receive updates and notifications.",
      "requiresConfirmation": false,
      "inputSchema": {
        "type": "object",
        "required": ["taskId"],
        "properties": {
          "taskId": {
            "type": "integer",
            "minimum": 1,
            "description": "ID of task to subscribe to"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string"
          },
          "error": {
            "type": "string"
          }
        }
      }
    },
    {
      "name": "unsubscribe_task",
      "description": "Unsubscribe the current user from a task to stop receiving updates.",
      "requiresConfirmation": false,
      "inputSchema": {
        "type": "object",
        "required": ["taskId"],
        "properties": {
          "taskId": {
            "type": "integer",
            "minimum": 1,
            "description": "ID of task to unsubscribe from"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string"
          },
          "error": {
            "type": "string"
          }
        }
      }
    },
    {
      "name": "create_team",
      "description": "Create a new team with optional initial members. The creator is automatically added to the team.",
      "requiresConfirmation": true,
      "inputSchema": {
        "type": "object",
        "required": ["name"],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255,
            "description": "Team name"
          },
          "description": {
            "type": "string",
            "maxLength": 255,
            "description": "Team description"
          },
          "memberIds": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "description": "Array of user IDs to add as team members. Creator is automatically included.",
            "uniqueItems": true
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer"
              },
              "name": {
                "type": "string"
              },
              "description": {
                "type": ["string", "null"]
              },
              "createdBy": {
                "type": "integer"
              },
              "createdAt": {
                "type": "string",
                "format": "date-time"
              },
              "teamsUsersBelongTo": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "userId": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          },
          "error": {
            "type": "string"
          }
        }
      }
    },
    {
      "name": "list_teams",
      "description": "Retrieve all teams in the system with their members.",
      "requiresConfirmation": false,
      "inputSchema": {
        "type": "object",
        "properties": {
          "includeMembers": {
            "type": "boolean",
            "default": true,
            "description": "Whether to include team member details"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success", "data"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer"
                },
                "name": {
                  "type": "string"
                },
                "description": {
                  "type": ["string", "null"]
                },
                "createdBy": {
                  "type": "integer"
                },
                "createdAt": {
                  "type": "string"
                },
                "teamsUsersBelongTo": {
                  "type": "array"
                }
              }
            }
          },
          "error": {
            "type": "string"
          }
        }
      }
    },
    {
      "name": "add_comment",
      "description": "Add a comment to a task. Useful for discussions and updates.",
      "requiresConfirmation": false,
      "inputSchema": {
        "type": "object",
        "required": ["taskId", "message"],
        "properties": {
          "taskId": {
            "type": "integer",
            "minimum": 1,
            "description": "ID of the task to comment on"
          },
          "message": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255,
            "description": "Comment text"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer"
              },
              "message": {
                "type": "string"
              },
              "userId": {
                "type": "integer"
              },
              "taskId": {
                "type": "integer"
              },
              "createdAt": {
                "type": "string",
                "format": "date-time"
              }
            }
          },
          "error": {
            "type": "string"
          }
        }
      }
    }
  ]
}
/**
 * MCP Service - API calls for AI Chat and MCP integration
 * 
 * This service handles communication with the AI endpoints:
 * - POST /api/v1/ai/chat - Chat with AI
 * - POST /api/v1/ai/chat/stream - Stream chat responses
 * - POST /api/v1/ai/execute-tool - Execute tool calls
 * - GET /api/v1/ai/health - Check AI service health
 */

import type {
	MCPMessage,
	MCPToolCall,
} from '../../types/mcp';

const AI_BASE_URL = '/api/v1/ai';

/**
 * Send a message to the AI and get a response
 */
export async function sendToAI(
	token: string,
	messages: MCPMessage[]
): Promise<{
	response: string;
	toolCall?: {
		id: string;
		tool: string;
		parameters: Record<string, any>;
		requiresConfirmation: boolean;
	};
}> {
	try {
		const response = await fetch(`${AI_BASE_URL}/chat`, {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${token}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({ messages }),
		});

		if (!response.ok) {
			throw new Error(`Failed to chat with AI: ${response.statusText}`);
		}

		const data = await response.json();
		return data.data;
	} catch (error) {
		console.error('Error chatting with AI:', error);
		throw error;
	}
}

/**
 * Execute an approved tool call
 */
export async function executeTool(
	token: string,
	toolCallId: string,
	tool: string,
	parameters: Record<string, any>
): Promise<any> {
	try {
		const response = await fetch(`${AI_BASE_URL}/execute-tool`, {
			method: 'POST',
			headers: {
				'Authorization': `Bearer ${token}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				toolCallId,
				tool,
				parameters,
			}),
		});

		if (!response.ok) {
			throw new Error(`Failed to execute tool: ${response.statusText}`);
		}

		const data = await response.json();
		return data.result;
	} catch (error) {
		console.error('Error executing tool:', error);
		throw error;
	}
}

/**
 * Check if AI service is available
 */
export async function checkAIHealth(token: string): Promise<boolean> {
	try {
		const response = await fetch(`${AI_BASE_URL}/health`, {
			method: 'GET',
			headers: {
				'Authorization': `Bearer ${token}`,
				'Content-Type': 'application/json',
			},
		});

		if (!response.ok) {
			return false;
		}

		const data = await response.json();
		return data.healthy;
	} catch (error) {
		console.error('Error checking AI health:', error);
		return false;
	}
}

/**
 * Stream chat responses (SSE)
 * Returns an async generator that yields response chunks
 */
export async function* streamChat(
	token: string,
	messages: MCPMessage[]
): AsyncGenerator<string, void, unknown> {
	const response = await fetch(`${AI_BASE_URL}/chat/stream`, {
		method: 'POST',
		headers: {
			'Authorization': `Bearer ${token}`,
			'Content-Type': 'application/json',
		},
		body: JSON.stringify({ messages }),
	});

	if (!response.ok || !response.body) {
		throw new Error('Failed to stream chat');
	}

	const reader = response.body.getReader();
	const decoder = new TextDecoder();

	try {
		while (true) {
			const { done, value } = await reader.read();
			
			if (done) break;

			const chunk = decoder.decode(value, { stream: true });
			const lines = chunk.split('\n');

			for (const line of lines) {
				if (line.startsWith('data: ')) {
					const data = line.slice(6);
					if (data === '[DONE]') {
						return;
					}
					try {
						const parsed = JSON.parse(data);
						if (parsed.chunk) {
							yield parsed.chunk;
						}
					} catch (e) {
						// Skip invalid JSON
					}
				}
			}
		}
	} finally {
		reader.releaseLock();
	}
}

/**
 * Format tool call for display
 */
export function formatToolCall(toolCall: MCPToolCall): string {
	return `Tool: ${toolCall.tool}\n\nParameters:\n${JSON.stringify(
		toolCall.parameters,
		null,
		2
	)}`;
}
